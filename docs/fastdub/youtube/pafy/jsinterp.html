<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fastdub.youtube.pafy.jsinterp API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fastdub.youtube.pafy.jsinterp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copied from youtube_dl

from __future__ import unicode_literals

import json
import operator
import re
import sys
import traceback


class ExtractorError(Exception):
    &#34;&#34;&#34;Error during info extraction.&#34;&#34;&#34;

    def __init__(self, msg, tb=None, expected=False, cause=None, video_id=None):
        &#34;&#34;&#34; tb, if given, is the original traceback (so that it can be printed out).
        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.
        &#34;&#34;&#34;

        if video_id is not None:
            msg = video_id + &#39;: &#39; + msg
        if cause:
            msg += &#39; (caused by %r)&#39; % cause
        super(ExtractorError, self).__init__(msg)

        self.traceback = tb
        self.exc_info = sys.exc_info()  # preserve original exception
        self.cause = cause
        self.video_id = video_id

    def format_traceback(self):
        if self.traceback is None:
            return None
        return &#39;&#39;.join(traceback.format_tb(self.traceback))


_OPERATORS = [
    (&#39;|&#39;, operator.or_),
    (&#39;^&#39;, operator.xor),
    (&#39;&amp;&#39;, operator.and_),
    (&#39;&gt;&gt;&#39;, operator.rshift),
    (&#39;&lt;&lt;&#39;, operator.lshift),
    (&#39;-&#39;, operator.sub),
    (&#39;+&#39;, operator.add),
    (&#39;%&#39;, operator.mod),
    (&#39;/&#39;, operator.truediv),
    (&#39;*&#39;, operator.mul),
]
_ASSIGN_OPERATORS = [(op + &#39;=&#39;, opfunc) for op, opfunc in _OPERATORS]
_ASSIGN_OPERATORS.append((&#39;=&#39;, lambda cur, right: right))

_NAME_RE = r&#39;[a-zA-Z_$][a-zA-Z_$0-9]*&#39;


class JSInterpreter(object):
    def __init__(self, code, objects=None):
        if objects is None:
            objects = {}
        self.code = code
        self._functions = {}
        self._objects = objects

    def interpret_statement(self, stmt, local_vars, allow_recursion=100):
        if allow_recursion &lt; 0:
            raise ExtractorError(&#39;Recursion limit reached&#39;)

        should_abort = False
        stmt = stmt.lstrip()
        stmt_m = re.match(r&#39;var\s&#39;, stmt)
        if stmt_m:
            expr = stmt[len(stmt_m.group(0)):]
        else:
            return_m = re.match(r&#39;return(?:\s+|$)&#39;, stmt)
            if return_m:
                expr = stmt[len(return_m.group(0)):]
                should_abort = True
            else:
                # Try interpreting it as an expression
                expr = stmt

        v = self.interpret_expression(expr, local_vars, allow_recursion)
        return v, should_abort

    def interpret_expression(self, expr, local_vars, allow_recursion):
        expr = expr.strip()

        if expr == &#39;&#39;:  # Empty expression
            return None

        if expr.startswith(&#39;(&#39;):
            parens_count = 0
            for m in re.finditer(r&#39;[()]&#39;, expr):
                if m.group(0) == &#39;(&#39;:
                    parens_count += 1
                else:
                    parens_count -= 1
                    if parens_count == 0:
                        sub_expr = expr[1:m.start()]
                        sub_result = self.interpret_expression(
                            sub_expr, local_vars, allow_recursion)
                        remaining_expr = expr[m.end():].strip()
                        if not remaining_expr:
                            return sub_result
                        else:
                            expr = json.dumps(sub_result) + remaining_expr
                        break
            else:
                raise ExtractorError(&#39;Premature end of parens in %r&#39; % expr)

        for op, opfunc in _ASSIGN_OPERATORS:
            m = re.match(r&#39;&#39;&#39;(?x)
                (?P&lt;out&gt;%s)(?:\[(?P&lt;index&gt;[^]]+?)])?
                \s*%s
                (?P&lt;expr&gt;.*)$&#39;&#39;&#39; % (_NAME_RE, re.escape(op)), expr)
            if not m:
                continue
            right_val = self.interpret_expression(
                m.group(&#39;expr&#39;), local_vars, allow_recursion - 1)

            if m.groupdict().get(&#39;index&#39;):
                lvar = local_vars[m.group(&#39;out&#39;)]
                idx = self.interpret_expression(
                    m.group(&#39;index&#39;), local_vars, allow_recursion)
                assert isinstance(idx, int)
                cur = lvar[idx]
                val = opfunc(cur, right_val)
                lvar[idx] = val
                return val
            else:
                cur = local_vars.get(m.group(&#39;out&#39;))
                val = opfunc(cur, right_val)
                local_vars[m.group(&#39;out&#39;)] = val
                return val

        if expr.isdigit():
            return int(expr)

        var_m = re.match(
            r&#39;(?!if|return|true|false)(?P&lt;name&gt;%s)$&#39; % _NAME_RE,
            expr)
        if var_m:
            return local_vars[var_m.group(&#39;name&#39;)]

        try:
            return json.loads(expr)
        except ValueError:
            pass

        m = re.match(
            r&#39;(?P&lt;var&gt;%s)\.(?P&lt;member&gt;[^(]+)(?:\(+(?P&lt;args&gt;[^()]*)\))?$&#39; % _NAME_RE,
            expr)
        if m:
            variable = m.group(&#39;var&#39;)
            member = m.group(&#39;member&#39;)
            arg_str = m.group(&#39;args&#39;)

            if variable in local_vars:
                obj = local_vars[variable]
            else:
                if variable not in self._objects:
                    self._objects[variable] = self.extract_object(variable)
                obj = self._objects[variable]

            if arg_str is None:
                # Member access
                if member == &#39;length&#39;:
                    return len(obj)
                return obj[member]

            assert expr.endswith(&#39;)&#39;)
            # Function call
            if arg_str == &#39;&#39;:
                argvals = tuple()
            else:
                argvals = tuple([
                    self.interpret_expression(v, local_vars, allow_recursion)
                    for v in arg_str.split(&#39;,&#39;)])

            if member == &#39;split&#39;:
                assert argvals == (&#39;&#39;,)
                return list(obj)
            if member == &#39;join&#39;:
                assert len(argvals) == 1
                return argvals[0].join(obj)
            if member == &#39;reverse&#39;:
                assert len(argvals) == 0
                obj.reverse()
                return obj
            if member == &#39;slice&#39;:
                assert len(argvals) == 1
                return obj[argvals[0]:]
            if member == &#39;splice&#39;:
                assert isinstance(obj, list)
                index, howMany = argvals
                res = []
                for i in range(index, min(index + howMany, len(obj))):
                    res.append(obj.pop(index))
                return res

            return obj[member](argvals)

        m = re.match(
            r&#39;(?P&lt;in&gt;%s)\[(?P&lt;idx&gt;.+)]$&#39; % _NAME_RE, expr)
        if m:
            val = local_vars[m.group(&#39;in&#39;)]
            idx = self.interpret_expression(
                m.group(&#39;idx&#39;), local_vars, allow_recursion - 1)
            return val[idx]

        for op, opfunc in _OPERATORS:
            m = re.match(r&#39;(?P&lt;x&gt;.+?)%s(?P&lt;y&gt;.+)&#39; % re.escape(op), expr)
            if not m:
                continue
            x, abort = self.interpret_statement(
                m.group(&#39;x&#39;), local_vars, allow_recursion - 1)
            if abort:
                raise ExtractorError(
                    &#39;Premature left-side return of %s in %r&#39; % (op, expr))
            y, abort = self.interpret_statement(
                m.group(&#39;y&#39;), local_vars, allow_recursion - 1)
            if abort:
                raise ExtractorError(
                    &#39;Premature right-side return of %s in %r&#39; % (op, expr))
            return opfunc(x, y)

        m = re.match(
            r&#39;^(?P&lt;func&gt;%s)\((?P&lt;args&gt;[a-zA-Z0-9_$,]+)\)$&#39; % _NAME_RE, expr)
        if m:
            fname = m.group(&#39;func&#39;)
            argvals = tuple([
                int(v) if v.isdigit() else local_vars[v]
                for v in m.group(&#39;args&#39;).split(&#39;,&#39;)])
            if fname not in self._functions:
                self._functions[fname] = self.extract_function(fname)
            return self._functions[fname](argvals)

        raise ExtractorError(&#39;Unsupported JS expression %r&#39; % expr)

    def extract_object(self, objname):
        obj = {}
        obj_m = re.search(
            (r&#39;(?:var\s+)?%s\s*=\s*\{&#39; % re.escape(objname)) +
            r&#39;\s*(?P&lt;fields&gt;([a-zA-Z$0-9]+\s*:\s*function\(.*?\)\s*\{.*?}(?:,\s*)?)*)&#39; +
            r&#39;}\s*;&#39;,
            self.code)
        fields = obj_m.group(&#39;fields&#39;)
        # Currently, it only supports function definitions
        fields_m = re.finditer(
            r&#39;(?P&lt;key&gt;[a-zA-Z$0-9]+)\s*:\s*function&#39;
            r&#39;\((?P&lt;args&gt;[a-z,]+)\){(?P&lt;code&gt;[^}]+)}&#39;,
            fields)
        for f in fields_m:
            argnames = f.group(&#39;args&#39;).split(&#39;,&#39;)
            obj[f.group(&#39;key&#39;)] = self.build_function(argnames, f.group(&#39;code&#39;))

        return obj

    def extract_function(self, funcname):
        func_m = re.search(
            r&#39;&#39;&#39;(?x)
                (?:function\s+%s|[{;,]\s*%s\s*=\s*function|var\s+%s\s*=\s*function)\s*
                \((?P&lt;args&gt;[^)]*)\)\s*
                \{(?P&lt;code&gt;[^}]+)}&#39;&#39;&#39; % (
                re.escape(funcname), re.escape(funcname), re.escape(funcname)),
            self.code)
        if func_m is None:
            raise ExtractorError(&#39;Could not find JS function %r&#39; % funcname)
        argnames = func_m.group(&#39;args&#39;).split(&#39;,&#39;)

        return self.build_function(argnames, func_m.group(&#39;code&#39;))

    def call_function(self, funcname, *args):
        f = self.extract_function(funcname)
        return f(args)

    def build_function(self, argnames, code):
        def resf(args):
            local_vars = dict(zip(argnames, args))
            res = None
            for stmt in code.split(&#39;;&#39;):
                res, abort = self.interpret_statement(stmt, local_vars)
                if abort:
                    break
            return res

        return resf</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fastdub.youtube.pafy.jsinterp.ExtractorError"><code class="flex name class">
<span>class <span class="ident">ExtractorError</span></span>
<span>(</span><span>msg, tb=None, expected=False, cause=None, video_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Error during info extraction.</p>
<p>tb, if given, is the original traceback (so that it can be printed out).
If expected is set, this is a normal error message and most likely not a bug in youtube-dl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtractorError(Exception):
    &#34;&#34;&#34;Error during info extraction.&#34;&#34;&#34;

    def __init__(self, msg, tb=None, expected=False, cause=None, video_id=None):
        &#34;&#34;&#34; tb, if given, is the original traceback (so that it can be printed out).
        If expected is set, this is a normal error message and most likely not a bug in youtube-dl.
        &#34;&#34;&#34;

        if video_id is not None:
            msg = video_id + &#39;: &#39; + msg
        if cause:
            msg += &#39; (caused by %r)&#39; % cause
        super(ExtractorError, self).__init__(msg)

        self.traceback = tb
        self.exc_info = sys.exc_info()  # preserve original exception
        self.cause = cause
        self.video_id = video_id

    def format_traceback(self):
        if self.traceback is None:
            return None
        return &#39;&#39;.join(traceback.format_tb(self.traceback))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fastdub.youtube.pafy.jsinterp.ExtractorError.format_traceback"><code class="name flex">
<span>def <span class="ident">format_traceback</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_traceback(self):
    if self.traceback is None:
        return None
    return &#39;&#39;.join(traceback.format_tb(self.traceback))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter"><code class="flex name class">
<span>class <span class="ident">JSInterpreter</span></span>
<span>(</span><span>code, objects=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSInterpreter(object):
    def __init__(self, code, objects=None):
        if objects is None:
            objects = {}
        self.code = code
        self._functions = {}
        self._objects = objects

    def interpret_statement(self, stmt, local_vars, allow_recursion=100):
        if allow_recursion &lt; 0:
            raise ExtractorError(&#39;Recursion limit reached&#39;)

        should_abort = False
        stmt = stmt.lstrip()
        stmt_m = re.match(r&#39;var\s&#39;, stmt)
        if stmt_m:
            expr = stmt[len(stmt_m.group(0)):]
        else:
            return_m = re.match(r&#39;return(?:\s+|$)&#39;, stmt)
            if return_m:
                expr = stmt[len(return_m.group(0)):]
                should_abort = True
            else:
                # Try interpreting it as an expression
                expr = stmt

        v = self.interpret_expression(expr, local_vars, allow_recursion)
        return v, should_abort

    def interpret_expression(self, expr, local_vars, allow_recursion):
        expr = expr.strip()

        if expr == &#39;&#39;:  # Empty expression
            return None

        if expr.startswith(&#39;(&#39;):
            parens_count = 0
            for m in re.finditer(r&#39;[()]&#39;, expr):
                if m.group(0) == &#39;(&#39;:
                    parens_count += 1
                else:
                    parens_count -= 1
                    if parens_count == 0:
                        sub_expr = expr[1:m.start()]
                        sub_result = self.interpret_expression(
                            sub_expr, local_vars, allow_recursion)
                        remaining_expr = expr[m.end():].strip()
                        if not remaining_expr:
                            return sub_result
                        else:
                            expr = json.dumps(sub_result) + remaining_expr
                        break
            else:
                raise ExtractorError(&#39;Premature end of parens in %r&#39; % expr)

        for op, opfunc in _ASSIGN_OPERATORS:
            m = re.match(r&#39;&#39;&#39;(?x)
                (?P&lt;out&gt;%s)(?:\[(?P&lt;index&gt;[^]]+?)])?
                \s*%s
                (?P&lt;expr&gt;.*)$&#39;&#39;&#39; % (_NAME_RE, re.escape(op)), expr)
            if not m:
                continue
            right_val = self.interpret_expression(
                m.group(&#39;expr&#39;), local_vars, allow_recursion - 1)

            if m.groupdict().get(&#39;index&#39;):
                lvar = local_vars[m.group(&#39;out&#39;)]
                idx = self.interpret_expression(
                    m.group(&#39;index&#39;), local_vars, allow_recursion)
                assert isinstance(idx, int)
                cur = lvar[idx]
                val = opfunc(cur, right_val)
                lvar[idx] = val
                return val
            else:
                cur = local_vars.get(m.group(&#39;out&#39;))
                val = opfunc(cur, right_val)
                local_vars[m.group(&#39;out&#39;)] = val
                return val

        if expr.isdigit():
            return int(expr)

        var_m = re.match(
            r&#39;(?!if|return|true|false)(?P&lt;name&gt;%s)$&#39; % _NAME_RE,
            expr)
        if var_m:
            return local_vars[var_m.group(&#39;name&#39;)]

        try:
            return json.loads(expr)
        except ValueError:
            pass

        m = re.match(
            r&#39;(?P&lt;var&gt;%s)\.(?P&lt;member&gt;[^(]+)(?:\(+(?P&lt;args&gt;[^()]*)\))?$&#39; % _NAME_RE,
            expr)
        if m:
            variable = m.group(&#39;var&#39;)
            member = m.group(&#39;member&#39;)
            arg_str = m.group(&#39;args&#39;)

            if variable in local_vars:
                obj = local_vars[variable]
            else:
                if variable not in self._objects:
                    self._objects[variable] = self.extract_object(variable)
                obj = self._objects[variable]

            if arg_str is None:
                # Member access
                if member == &#39;length&#39;:
                    return len(obj)
                return obj[member]

            assert expr.endswith(&#39;)&#39;)
            # Function call
            if arg_str == &#39;&#39;:
                argvals = tuple()
            else:
                argvals = tuple([
                    self.interpret_expression(v, local_vars, allow_recursion)
                    for v in arg_str.split(&#39;,&#39;)])

            if member == &#39;split&#39;:
                assert argvals == (&#39;&#39;,)
                return list(obj)
            if member == &#39;join&#39;:
                assert len(argvals) == 1
                return argvals[0].join(obj)
            if member == &#39;reverse&#39;:
                assert len(argvals) == 0
                obj.reverse()
                return obj
            if member == &#39;slice&#39;:
                assert len(argvals) == 1
                return obj[argvals[0]:]
            if member == &#39;splice&#39;:
                assert isinstance(obj, list)
                index, howMany = argvals
                res = []
                for i in range(index, min(index + howMany, len(obj))):
                    res.append(obj.pop(index))
                return res

            return obj[member](argvals)

        m = re.match(
            r&#39;(?P&lt;in&gt;%s)\[(?P&lt;idx&gt;.+)]$&#39; % _NAME_RE, expr)
        if m:
            val = local_vars[m.group(&#39;in&#39;)]
            idx = self.interpret_expression(
                m.group(&#39;idx&#39;), local_vars, allow_recursion - 1)
            return val[idx]

        for op, opfunc in _OPERATORS:
            m = re.match(r&#39;(?P&lt;x&gt;.+?)%s(?P&lt;y&gt;.+)&#39; % re.escape(op), expr)
            if not m:
                continue
            x, abort = self.interpret_statement(
                m.group(&#39;x&#39;), local_vars, allow_recursion - 1)
            if abort:
                raise ExtractorError(
                    &#39;Premature left-side return of %s in %r&#39; % (op, expr))
            y, abort = self.interpret_statement(
                m.group(&#39;y&#39;), local_vars, allow_recursion - 1)
            if abort:
                raise ExtractorError(
                    &#39;Premature right-side return of %s in %r&#39; % (op, expr))
            return opfunc(x, y)

        m = re.match(
            r&#39;^(?P&lt;func&gt;%s)\((?P&lt;args&gt;[a-zA-Z0-9_$,]+)\)$&#39; % _NAME_RE, expr)
        if m:
            fname = m.group(&#39;func&#39;)
            argvals = tuple([
                int(v) if v.isdigit() else local_vars[v]
                for v in m.group(&#39;args&#39;).split(&#39;,&#39;)])
            if fname not in self._functions:
                self._functions[fname] = self.extract_function(fname)
            return self._functions[fname](argvals)

        raise ExtractorError(&#39;Unsupported JS expression %r&#39; % expr)

    def extract_object(self, objname):
        obj = {}
        obj_m = re.search(
            (r&#39;(?:var\s+)?%s\s*=\s*\{&#39; % re.escape(objname)) +
            r&#39;\s*(?P&lt;fields&gt;([a-zA-Z$0-9]+\s*:\s*function\(.*?\)\s*\{.*?}(?:,\s*)?)*)&#39; +
            r&#39;}\s*;&#39;,
            self.code)
        fields = obj_m.group(&#39;fields&#39;)
        # Currently, it only supports function definitions
        fields_m = re.finditer(
            r&#39;(?P&lt;key&gt;[a-zA-Z$0-9]+)\s*:\s*function&#39;
            r&#39;\((?P&lt;args&gt;[a-z,]+)\){(?P&lt;code&gt;[^}]+)}&#39;,
            fields)
        for f in fields_m:
            argnames = f.group(&#39;args&#39;).split(&#39;,&#39;)
            obj[f.group(&#39;key&#39;)] = self.build_function(argnames, f.group(&#39;code&#39;))

        return obj

    def extract_function(self, funcname):
        func_m = re.search(
            r&#39;&#39;&#39;(?x)
                (?:function\s+%s|[{;,]\s*%s\s*=\s*function|var\s+%s\s*=\s*function)\s*
                \((?P&lt;args&gt;[^)]*)\)\s*
                \{(?P&lt;code&gt;[^}]+)}&#39;&#39;&#39; % (
                re.escape(funcname), re.escape(funcname), re.escape(funcname)),
            self.code)
        if func_m is None:
            raise ExtractorError(&#39;Could not find JS function %r&#39; % funcname)
        argnames = func_m.group(&#39;args&#39;).split(&#39;,&#39;)

        return self.build_function(argnames, func_m.group(&#39;code&#39;))

    def call_function(self, funcname, *args):
        f = self.extract_function(funcname)
        return f(args)

    def build_function(self, argnames, code):
        def resf(args):
            local_vars = dict(zip(argnames, args))
            res = None
            for stmt in code.split(&#39;;&#39;):
                res, abort = self.interpret_statement(stmt, local_vars)
                if abort:
                    break
            return res

        return resf</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.build_function"><code class="name flex">
<span>def <span class="ident">build_function</span></span>(<span>self, argnames, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_function(self, argnames, code):
    def resf(args):
        local_vars = dict(zip(argnames, args))
        res = None
        for stmt in code.split(&#39;;&#39;):
            res, abort = self.interpret_statement(stmt, local_vars)
            if abort:
                break
        return res

    return resf</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.call_function"><code class="name flex">
<span>def <span class="ident">call_function</span></span>(<span>self, funcname, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_function(self, funcname, *args):
    f = self.extract_function(funcname)
    return f(args)</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_function"><code class="name flex">
<span>def <span class="ident">extract_function</span></span>(<span>self, funcname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_function(self, funcname):
    func_m = re.search(
        r&#39;&#39;&#39;(?x)
            (?:function\s+%s|[{;,]\s*%s\s*=\s*function|var\s+%s\s*=\s*function)\s*
            \((?P&lt;args&gt;[^)]*)\)\s*
            \{(?P&lt;code&gt;[^}]+)}&#39;&#39;&#39; % (
            re.escape(funcname), re.escape(funcname), re.escape(funcname)),
        self.code)
    if func_m is None:
        raise ExtractorError(&#39;Could not find JS function %r&#39; % funcname)
    argnames = func_m.group(&#39;args&#39;).split(&#39;,&#39;)

    return self.build_function(argnames, func_m.group(&#39;code&#39;))</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_object"><code class="name flex">
<span>def <span class="ident">extract_object</span></span>(<span>self, objname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_object(self, objname):
    obj = {}
    obj_m = re.search(
        (r&#39;(?:var\s+)?%s\s*=\s*\{&#39; % re.escape(objname)) +
        r&#39;\s*(?P&lt;fields&gt;([a-zA-Z$0-9]+\s*:\s*function\(.*?\)\s*\{.*?}(?:,\s*)?)*)&#39; +
        r&#39;}\s*;&#39;,
        self.code)
    fields = obj_m.group(&#39;fields&#39;)
    # Currently, it only supports function definitions
    fields_m = re.finditer(
        r&#39;(?P&lt;key&gt;[a-zA-Z$0-9]+)\s*:\s*function&#39;
        r&#39;\((?P&lt;args&gt;[a-z,]+)\){(?P&lt;code&gt;[^}]+)}&#39;,
        fields)
    for f in fields_m:
        argnames = f.group(&#39;args&#39;).split(&#39;,&#39;)
        obj[f.group(&#39;key&#39;)] = self.build_function(argnames, f.group(&#39;code&#39;))

    return obj</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_expression"><code class="name flex">
<span>def <span class="ident">interpret_expression</span></span>(<span>self, expr, local_vars, allow_recursion)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_expression(self, expr, local_vars, allow_recursion):
    expr = expr.strip()

    if expr == &#39;&#39;:  # Empty expression
        return None

    if expr.startswith(&#39;(&#39;):
        parens_count = 0
        for m in re.finditer(r&#39;[()]&#39;, expr):
            if m.group(0) == &#39;(&#39;:
                parens_count += 1
            else:
                parens_count -= 1
                if parens_count == 0:
                    sub_expr = expr[1:m.start()]
                    sub_result = self.interpret_expression(
                        sub_expr, local_vars, allow_recursion)
                    remaining_expr = expr[m.end():].strip()
                    if not remaining_expr:
                        return sub_result
                    else:
                        expr = json.dumps(sub_result) + remaining_expr
                    break
        else:
            raise ExtractorError(&#39;Premature end of parens in %r&#39; % expr)

    for op, opfunc in _ASSIGN_OPERATORS:
        m = re.match(r&#39;&#39;&#39;(?x)
            (?P&lt;out&gt;%s)(?:\[(?P&lt;index&gt;[^]]+?)])?
            \s*%s
            (?P&lt;expr&gt;.*)$&#39;&#39;&#39; % (_NAME_RE, re.escape(op)), expr)
        if not m:
            continue
        right_val = self.interpret_expression(
            m.group(&#39;expr&#39;), local_vars, allow_recursion - 1)

        if m.groupdict().get(&#39;index&#39;):
            lvar = local_vars[m.group(&#39;out&#39;)]
            idx = self.interpret_expression(
                m.group(&#39;index&#39;), local_vars, allow_recursion)
            assert isinstance(idx, int)
            cur = lvar[idx]
            val = opfunc(cur, right_val)
            lvar[idx] = val
            return val
        else:
            cur = local_vars.get(m.group(&#39;out&#39;))
            val = opfunc(cur, right_val)
            local_vars[m.group(&#39;out&#39;)] = val
            return val

    if expr.isdigit():
        return int(expr)

    var_m = re.match(
        r&#39;(?!if|return|true|false)(?P&lt;name&gt;%s)$&#39; % _NAME_RE,
        expr)
    if var_m:
        return local_vars[var_m.group(&#39;name&#39;)]

    try:
        return json.loads(expr)
    except ValueError:
        pass

    m = re.match(
        r&#39;(?P&lt;var&gt;%s)\.(?P&lt;member&gt;[^(]+)(?:\(+(?P&lt;args&gt;[^()]*)\))?$&#39; % _NAME_RE,
        expr)
    if m:
        variable = m.group(&#39;var&#39;)
        member = m.group(&#39;member&#39;)
        arg_str = m.group(&#39;args&#39;)

        if variable in local_vars:
            obj = local_vars[variable]
        else:
            if variable not in self._objects:
                self._objects[variable] = self.extract_object(variable)
            obj = self._objects[variable]

        if arg_str is None:
            # Member access
            if member == &#39;length&#39;:
                return len(obj)
            return obj[member]

        assert expr.endswith(&#39;)&#39;)
        # Function call
        if arg_str == &#39;&#39;:
            argvals = tuple()
        else:
            argvals = tuple([
                self.interpret_expression(v, local_vars, allow_recursion)
                for v in arg_str.split(&#39;,&#39;)])

        if member == &#39;split&#39;:
            assert argvals == (&#39;&#39;,)
            return list(obj)
        if member == &#39;join&#39;:
            assert len(argvals) == 1
            return argvals[0].join(obj)
        if member == &#39;reverse&#39;:
            assert len(argvals) == 0
            obj.reverse()
            return obj
        if member == &#39;slice&#39;:
            assert len(argvals) == 1
            return obj[argvals[0]:]
        if member == &#39;splice&#39;:
            assert isinstance(obj, list)
            index, howMany = argvals
            res = []
            for i in range(index, min(index + howMany, len(obj))):
                res.append(obj.pop(index))
            return res

        return obj[member](argvals)

    m = re.match(
        r&#39;(?P&lt;in&gt;%s)\[(?P&lt;idx&gt;.+)]$&#39; % _NAME_RE, expr)
    if m:
        val = local_vars[m.group(&#39;in&#39;)]
        idx = self.interpret_expression(
            m.group(&#39;idx&#39;), local_vars, allow_recursion - 1)
        return val[idx]

    for op, opfunc in _OPERATORS:
        m = re.match(r&#39;(?P&lt;x&gt;.+?)%s(?P&lt;y&gt;.+)&#39; % re.escape(op), expr)
        if not m:
            continue
        x, abort = self.interpret_statement(
            m.group(&#39;x&#39;), local_vars, allow_recursion - 1)
        if abort:
            raise ExtractorError(
                &#39;Premature left-side return of %s in %r&#39; % (op, expr))
        y, abort = self.interpret_statement(
            m.group(&#39;y&#39;), local_vars, allow_recursion - 1)
        if abort:
            raise ExtractorError(
                &#39;Premature right-side return of %s in %r&#39; % (op, expr))
        return opfunc(x, y)

    m = re.match(
        r&#39;^(?P&lt;func&gt;%s)\((?P&lt;args&gt;[a-zA-Z0-9_$,]+)\)$&#39; % _NAME_RE, expr)
    if m:
        fname = m.group(&#39;func&#39;)
        argvals = tuple([
            int(v) if v.isdigit() else local_vars[v]
            for v in m.group(&#39;args&#39;).split(&#39;,&#39;)])
        if fname not in self._functions:
            self._functions[fname] = self.extract_function(fname)
        return self._functions[fname](argvals)

    raise ExtractorError(&#39;Unsupported JS expression %r&#39; % expr)</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_statement"><code class="name flex">
<span>def <span class="ident">interpret_statement</span></span>(<span>self, stmt, local_vars, allow_recursion=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret_statement(self, stmt, local_vars, allow_recursion=100):
    if allow_recursion &lt; 0:
        raise ExtractorError(&#39;Recursion limit reached&#39;)

    should_abort = False
    stmt = stmt.lstrip()
    stmt_m = re.match(r&#39;var\s&#39;, stmt)
    if stmt_m:
        expr = stmt[len(stmt_m.group(0)):]
    else:
        return_m = re.match(r&#39;return(?:\s+|$)&#39;, stmt)
        if return_m:
            expr = stmt[len(return_m.group(0)):]
            should_abort = True
        else:
            # Try interpreting it as an expression
            expr = stmt

    v = self.interpret_expression(expr, local_vars, allow_recursion)
    return v, should_abort</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fastdub.youtube.pafy" href="index.html">fastdub.youtube.pafy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fastdub.youtube.pafy.jsinterp.ExtractorError" href="#fastdub.youtube.pafy.jsinterp.ExtractorError">ExtractorError</a></code></h4>
<ul class="">
<li><code><a title="fastdub.youtube.pafy.jsinterp.ExtractorError.format_traceback" href="#fastdub.youtube.pafy.jsinterp.ExtractorError.format_traceback">format_traceback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter">JSInterpreter</a></code></h4>
<ul class="">
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.build_function" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.build_function">build_function</a></code></li>
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.call_function" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.call_function">call_function</a></code></li>
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_function" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_function">extract_function</a></code></li>
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_object" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.extract_object">extract_object</a></code></li>
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_expression" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_expression">interpret_expression</a></code></li>
<li><code><a title="fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_statement" href="#fastdub.youtube.pafy.jsinterp.JSInterpreter.interpret_statement">interpret_statement</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>