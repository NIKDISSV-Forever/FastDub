<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fastdub.youtube.pafy.backend_internal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fastdub.youtube.pafy.backend_internal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import hashlib
import json
import logging
import os
import re
import sys
import tempfile
import time
from urllib.parse import parse_qs, unquote_plus
from xml.etree import ElementTree

from . import g
from .backend_shared import BasePafy, BaseStream
from .jsinterp import JSInterpreter
from .pafy import dbg, fetch_decode, get_categoryname

uni, pyver = str, 3
early_py_version = sys.version_info[:2] &lt; (2, 7)
funcmap = {}


class InternPafy(BasePafy):
    def __init__(self, *args, **kwargs):
        self.sm = []
        self.asm = []
        self.dash = []
        self.js_url = None  # if js_url is set then has new stream map
        self._dashurl = None
        self.age_ver = False
        self._formats = None
        self.ciphertag = None  # used by Stream class in url property def
        super(InternPafy, self).__init__(*args, **kwargs)

    def _fetch_basic(self):
        &#34;&#34;&#34; Fetch basic data and streams. &#34;&#34;&#34;
        if self._have_basic:
            return

        allinfo = get_video_info(self.videoid, self.callback)

        if self.callback:
            self.callback(&#34;Fetched video info&#34;)

        def _get_lst(key, default=&#34;unknown&#34;, dic=allinfo):
            &#34;&#34;&#34; Dict get function, returns first index. &#34;&#34;&#34;
            retval = dic.get(key, default)
            return retval[0] if retval != default else default

        self._title = _get_lst(&#39;title&#39;)
        self._dashurl = _get_lst(&#39;dashmpd&#39;)
        self._author = _get_lst(&#39;author&#39;)
        self._rating = float(_get_lst(&#39;avg_rating&#39;, 0.0))
        self._length = int(_get_lst(&#39;length_seconds&#39;, 0))
        self._viewcount = int(_get_lst(&#39;view_count&#39;, 0))
        self._thumb = unquote_plus(_get_lst(&#39;thumbnail_url&#39;, &#34;&#34;))
        self._formats = [x.split(&#34;/&#34;) for x in _get_lst(&#39;fmt_list&#39;).split(&#34;,&#34;)]
        self._keywords = _get_lst(&#39;keywords&#39;, &#34;&#34;).split(&#39;,&#39;)
        self._bigthumb = _get_lst(&#39;iurlsd&#39;, &#34;&#34;)
        self._bigthumbhd = _get_lst(&#39;iurlsdmaxres&#39;, &#34;&#34;)
        self.ciphertag = _get_lst(&#34;use_cipher_signature&#34;) == &#34;True&#34;
        self.sm = _extract_smap(g.UEFSM, allinfo, True)
        self.asm = _extract_smap(g.AF, allinfo, True)
        dbg(&#34;extracted stream maps&#34;)

        sm_ciphertag = &#34;s&#34; in self.sm[0]

        if self.ciphertag != sm_ciphertag:
            dbg(&#34;ciphertag mismatch&#34;)
            self.ciphertag = not self.ciphertag

        watch_url = g.urls[&#39;watchv&#39;] % self.videoid
        if self.callback:
            self.callback(&#34;Fetching watch page&#34;)
        watchinfo = fetch_decode(watch_url)  # unicode
        dbg(&#34;Fetched watch page&#34;)
        if self.callback:
            self.callback(&#34;Fetched watch page&#34;)
        self.age_ver = re.search(r&#39;player-age-gate-content&#34;&gt;&#39;, watchinfo) is not None

        if self.ciphertag:
            dbg(&#34;Encrypted signature detected.&#34;)

            if not self.age_ver:
                smaps, js_url, mainfunc = get_js_sm(watchinfo, self.callback)
                funcmap[js_url] = mainfunc
                self.sm, self.asm = smaps
                self.js_url = js_url
                dashsig = re.search(r&#34;/s/([\w.]+)&#34;, self._dashurl).group(1)
                dbg(&#34;decrypting dash sig&#34;)
                goodsig = _decodesig(dashsig, js_url, self.callback)
                self._dashurl = re.sub(r&#34;/s/[\w.]+&#34;,
                                       &#34;/signature/%s&#34; % goodsig, self._dashurl)

            else:
                s = re.search(r&#34;/s/([\w.]+)&#34;, self._dashurl).group(1)
                s = s[2:63] + s[82] + s[64:82] + s[63]
                self._dashurl = re.sub(r&#34;/s/[\w.]+&#34;,
                                       &#34;/signature/%s&#34; % s, self._dashurl)

        if self._dashurl != &#39;unknown&#39;:
            self.dash = _extract_dash(self._dashurl)
        self._have_basic = 1
        self._process_streams()
        self.expiry = time.time() + g.lifespan

    def _fetch_gdata(self):
        &#34;&#34;&#34; Extract gdata values, fetch gdata if necessary. &#34;&#34;&#34;
        if self._have_gdata:
            return

        item = self._get_video_gdata(self.videoid)[&#39;items&#39;][0]
        snippet = item[&#39;snippet&#39;]
        self._published = uni(snippet[&#39;publishedAt&#39;])
        self._description = uni(snippet[&#34;description&#34;])
        self._category = get_categoryname(snippet[&#39;categoryId&#39;])
        # TODO: Make sure actual usename is not available through the api
        self._username = uni(snippet[&#39;channelTitle&#39;])
        statistics = item[&#34;statistics&#34;]
        self._likes = int(statistics[&#34;likeCount&#34;])
        self._dislikes = int(statistics[&#34;dislikeCount&#34;])
        self._have_gdata = 1

    def _process_streams(self):
        &#34;&#34;&#34; Create Stream object lists from internal stream maps. &#34;&#34;&#34;
        if not self._have_basic:
            self._fetch_basic()

        streams = [InternStream(z, self) for z in self.sm]
        streams = [x for x in streams if x.itag in g.itags]
        adpt_streams = [InternStream(z, self) for z in self.asm]
        adpt_streams = [x for x in adpt_streams if x.itag in g.itags]
        dash_streams = [InternStream(z, self) for z in self.dash]
        dash_streams = [x for x in dash_streams if x.itag in g.itags]
        audiostreams = [x for x in adpt_streams if x.bitrate]
        videostreams = [x for x in adpt_streams if not x.bitrate]
        dash_itags = [x.itag for x in dash_streams]
        audiostreams = [x for x in audiostreams if x.itag not in dash_itags]
        videostreams = [x for x in videostreams if x.itag not in dash_itags]
        audiostreams += [x for x in dash_streams if x.mediatype == &#34;audio&#34;]
        videostreams += [x for x in dash_streams if x.mediatype != &#34;audio&#34;]
        audiostreams = sorted(audiostreams, key=lambda x: x.rawbitrate,
                              reverse=True)
        videostreams = sorted(videostreams, key=lambda x: x.dimensions,
                              reverse=True)
        m4astreams = [x for x in audiostreams if x.extension == &#34;m4a&#34;]
        oggstreams = [x for x in audiostreams if x.extension == &#34;ogg&#34;]
        self._streams = streams
        self._audiostreams = audiostreams
        self._videostreams = videostreams
        self._m4astreams, self._oggstreams = m4astreams, oggstreams
        self._allstreams = streams + videostreams + audiostreams


class InternStream(BaseStream):
    def __init__(self, sm, parent):
        super(InternStream, self).__init__(parent)

        self._itag = sm[&#39;itag&#39;]
        # is_dash = &#34;width&#34; in sm and &#34;height&#34; in sm
        is_dash = &#34;dash&#34; in sm

        if self._itag not in g.itags:
            logging.warning(&#34;Unknown itag: %s&#34;, self._itag)
            return

        self._mediatype = g.itags[self.itag][2]
        self._threed = &#39;stereo3d&#39; in sm and sm[&#39;stereo3d&#39;] == &#39;1&#39;

        if is_dash:
            if sm[&#39;width&#39;] != &#34;None&#34;:  # dash video
                self._resolution = &#34;%sx%s&#34; % (sm[&#39;width&#39;], sm[&#39;height&#39;])
                self._quality = self._resolution
                self._dimensions = (int(sm[&#39;width&#39;]), int(sm[&#39;height&#39;]))

            else:  # dash audio
                self._resolution = &#34;0x0&#34;
                self._dimensions = (0, 0)
                self._rawbitrate = int(sm[&#39;bitrate&#39;])
                # self._bitrate = uni(int(sm[&#39;bitrate&#39;]) // 1024) + &#34;k&#34;
                self._bitrate = g.itags[self.itag][0]
                self._quality = self._bitrate

            self._fsize = int(sm[&#39;size&#39;] or 0)
            # self._bitrate = sm[&#39;bitrate&#39;]
            # self._rawbitrate = uni(int(self._bitrate) // 1024) + &#34;k&#34;

        else:  # not dash
            self._resolution = g.itags[self.itag][0]
            self._dimensions = tuple(self.resolution.split(&#34;-&#34;)[0].split(&#34;x&#34;))
            self._dimensions = tuple([int(x) if x.isdigit() else x for x in
                                      self._dimensions])
            self._quality = self.resolution

        self._extension = g.itags[self.itag][1]
        self._title = parent.title
        self.encrypted = &#39;s&#39; in sm
        self._parent = parent
        self._filename = self.generate_filename()
        self._notes = g.itags[self.itag][3]
        self._rawurl = sm[&#39;url&#39;]
        self._sig = sm[&#39;s&#39;] if self.encrypted else sm.get(&#34;sig&#34;)
        self._active = False

        if self.mediatype == &#34;audio&#34; and not is_dash:
            self._dimensions = (0, 0)
            self._bitrate = self.resolution
            self._quality = self.bitrate
            self._resolution = &#34;0x0&#34;
            self._rawbitrate = int(sm[&#34;bitrate&#34;])

    @property
    def url(self):
        &#34;&#34;&#34; Return the url, decrypt if required. &#34;&#34;&#34;
        if not self._url:

            if self._parent.age_ver:

                if self._sig:
                    s = self._sig
                    self._sig = s[2:63] + s[82] + s[64:82] + s[63]

            elif self.encrypted:
                self._sig = _decodesig(self._sig, self._parent.js_url,
                                       self._parent.callback)

            self._url = _make_url(self._rawurl, self._sig)

        return self._url


def parseqs(data):
    &#34;&#34;&#34; parse_qs, return unicode. &#34;&#34;&#34;
    if type(data) == uni:
        return parse_qs(data)

    elif pyver == 3:
        data = data.decode(&#34;utf8&#34;)
        data = parse_qs(data)

    else:
        data = parse_qs(data)
        out = {}

        for k, v in data.items():
            k = k.decode(&#34;utf8&#34;)
            out[k] = [x.decode(&#34;utf8&#34;) for x in v]
            data = out

    return data


def get_video_info(video_id, callback, newurl=None):
    &#34;&#34;&#34; Return info for video_id.  Returns dict. &#34;&#34;&#34;
    # TODO: see if there is a way to avoid retrieving the embed page
    #       just for this, or to use it for more. This was coppied from
    #       youtube-dl.
    embed_webpage = fetch_decode(g.urls[&#39;embed&#39;])
    sts = re.search(r&#39;sts&#34;\s*:\s*(\d+)&#39;, embed_webpage).group(1)

    url = g.urls[&#39;vidinfo&#39;] % (video_id, video_id, sts)
    url = newurl if newurl else url
    info = fetch_decode(url)  # bytes
    info = parseqs(info)  # unicode dict
    dbg(&#34;Fetched video info%s&#34;, &#34; (age ver)&#34; if newurl else &#34;&#34;)

    if info[&#39;status&#39;][0] == &#34;fail&#34;:
        reason = info[&#39;reason&#39;][0] or &#34;Bad video argument&#34;
        raise IOError(&#34;Youtube says: %s [%s]&#34; % (reason, video_id))

    return info


def _extract_smap(map_name, dic, zero_idx=True):
    &#34;&#34;&#34; Extract stream map, returns list of dicts. &#34;&#34;&#34;
    if map_name in dic:
        smap = dic.get(map_name)
        smap = smap[0] if zero_idx else smap
        smap = smap.split(&#34;,&#34;)
        smap = [parseqs(x) for x in smap]
        return [dict((k, v[0]) for k, v in x.items()) for x in smap]

    return []


def _extract_dash(dashurl):
    &#34;&#34;&#34; Download dash url and extract some data. &#34;&#34;&#34;
    # pylint: disable = R0914
    dbg(&#34;Fetching dash page&#34;)
    dashdata = fetch_decode(dashurl)
    dbg(&#34;DASH list fetched&#34;)
    ns = &#34;{urn:mpeg:DASH:schema:MPD:2011}&#34;
    ytns = &#34;{http://youtube.com/yt/2012/10/10}&#34;
    tree = ElementTree.fromstring(dashdata)
    tlist = tree.findall(&#34;.//%sRepresentation&#34; % ns)
    dashmap = []

    for x in tlist:
        baseurl = x.find(&#34;%sBaseURL&#34; % ns)
        url = baseurl.text
        size = baseurl.get(&#34;%scontentLength&#34; % ytns)
        bitrate = x.get(&#34;bandwidth&#34;)
        itag = uni(x.get(&#34;id&#34;))
        width = uni(x.get(&#34;width&#34;))
        height = uni(x.get(&#34;height&#34;))
        dashmap.append(dict(bitrate=bitrate,
                            dash=True,
                            itag=itag,
                            width=width,
                            height=height,
                            url=url,
                            size=size))
    return dashmap


def _get_mainfunc_from_js(js):
    &#34;&#34;&#34; Return main signature decryption function from javascript as dict. &#34;&#34;&#34;
    dbg(&#34;Scanning js for main function.&#34;)
    m = re.search(r&#39;\.sig\|\|([a-zA-Z0-9$]+)\(&#39;, js)
    funcname = m.group(1)
    dbg(&#34;Found main function: %s&#34;, funcname)
    jsi = JSInterpreter(js)
    return jsi.extract_function(funcname)


def _decodesig(sig, js_url, callback):
    &#34;&#34;&#34;  Return decrypted sig given an encrypted sig and js_url key. &#34;&#34;&#34;
    # lookup main function in funcmap dict
    mainfunction = funcmap[js_url]

    # fill in function argument with signature
    if callback:
        callback(&#34;Decrypting signature&#34;)
    solved = mainfunction([sig])
    dbg(&#34;Decrypted sig = %s...&#34;, solved[:30])
    if callback:
        callback(&#34;Decrypted signature&#34;)
    return solved


def fetch_cached(url, callback, encoding=None, dbg_ref=&#34;&#34;, file_prefix=&#34;&#34;):
    &#34;&#34;&#34; Fetch url - from tmpdir if already retrieved. &#34;&#34;&#34;
    tmpdir = os.path.join(tempfile.gettempdir(), &#34;pafy&#34;)

    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)

    url_md5 = hashlib.md5(url.encode(&#34;utf8&#34;)).hexdigest()
    cached_filename = os.path.join(tmpdir, file_prefix + url_md5)

    if os.path.exists(cached_filename):
        dbg(&#34;fetched %s from cache&#34;, dbg_ref)

        with open(cached_filename) as f:
            retval = f.read()

        return retval

    else:
        data = fetch_decode(url, &#34;utf8&#34;)  # unicode
        dbg(&#34;Fetched %s&#34;, dbg_ref)
        if callback:
            callback(&#34;Fetched %s&#34; % dbg_ref)

        with open(cached_filename, &#34;w&#34;) as f:
            f.write(data)

        # prune files after write
        prune_files(tmpdir, file_prefix)
        return data


def prune_files(path, prefix=&#34;&#34;, age_max=3600 * 24 * 14, count_max=4):
    &#34;&#34;&#34; Remove the oldest files from path that start with prefix.

    remove files older than age_max, leave maximum of count_max files.
    &#34;&#34;&#34;
    tempfiles = []

    if not os.path.isdir(path):
        return

    for f in os.listdir(path):
        filepath = os.path.join(path, f)

        if os.path.isfile(filepath) and f.startswith(prefix):
            age = time.time() - os.path.getmtime(filepath)

            if age &gt; age_max:
                os.unlink(filepath)

            else:
                tempfiles.append((filepath, age))

    tempfiles = sorted(tempfiles, key=lambda x: x[1], reverse=True)

    for f in tempfiles[:-count_max]:
        os.unlink(f[0])


def get_js_sm(watchinfo, callback):
    &#34;&#34;&#34; Fetch watchinfo page and extract stream map and js funcs if not known.

    This function is needed by videos with encrypted signatures.
    If the js url referred to in the watchv page is not a key in funcmap,
    the javascript is fetched and functions extracted.

    Returns streammap (list of dicts), js url (str)  and funcs (dict)

    &#34;&#34;&#34;
    m = re.search(g.jsplayer, watchinfo)
    myjson = json.loads(m.group(1))
    stream_info = myjson[&#39;args&#39;]
    sm = _extract_smap(g.UEFSM, stream_info, False)
    asm = _extract_smap(g.AF, stream_info, False)
    js_url = myjson[&#39;assets&#39;][&#39;js&#39;]
    js_url = &#34;https:&#34; + js_url if js_url.startswith(&#34;//&#34;) else js_url
    mainfunc = funcmap.get(js_url)

    if not mainfunc:
        dbg(&#34;Fetching javascript&#34;)
        if callback:
            callback(&#34;Fetching javascript&#34;)
        javascript = fetch_cached(js_url, callback, encoding=&#34;utf8&#34;,
                                  dbg_ref=&#34;javascript&#34;, file_prefix=&#34;js-&#34;)
        mainfunc = _get_mainfunc_from_js(javascript)

    elif mainfunc:
        dbg(&#34;Using functions in memory extracted from %s&#34;, js_url)
        dbg(&#34;Mem contains %s js func sets&#34;, len(funcmap))

    return (sm, asm), js_url, mainfunc


def _make_url(raw, sig, quick=True):
    &#34;&#34;&#34; Return usable url. Set quick=False to disable ratebypass override. &#34;&#34;&#34;
    if quick and &#34;ratebypass=&#34; not in raw:
        raw += &#34;&amp;ratebypass=yes&#34;

    if &#34;signature=&#34; not in raw:

        if sig is None:
            raise IOError(&#34;Error retrieving url&#34;)

        raw += &#34;&amp;signature=&#34; + sig

    return raw</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fastdub.youtube.pafy.backend_internal.fetch_cached"><code class="name flex">
<span>def <span class="ident">fetch_cached</span></span>(<span>url, callback, encoding=None, dbg_ref='', file_prefix='')</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch url - from tmpdir if already retrieved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_cached(url, callback, encoding=None, dbg_ref=&#34;&#34;, file_prefix=&#34;&#34;):
    &#34;&#34;&#34; Fetch url - from tmpdir if already retrieved. &#34;&#34;&#34;
    tmpdir = os.path.join(tempfile.gettempdir(), &#34;pafy&#34;)

    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)

    url_md5 = hashlib.md5(url.encode(&#34;utf8&#34;)).hexdigest()
    cached_filename = os.path.join(tmpdir, file_prefix + url_md5)

    if os.path.exists(cached_filename):
        dbg(&#34;fetched %s from cache&#34;, dbg_ref)

        with open(cached_filename) as f:
            retval = f.read()

        return retval

    else:
        data = fetch_decode(url, &#34;utf8&#34;)  # unicode
        dbg(&#34;Fetched %s&#34;, dbg_ref)
        if callback:
            callback(&#34;Fetched %s&#34; % dbg_ref)

        with open(cached_filename, &#34;w&#34;) as f:
            f.write(data)

        # prune files after write
        prune_files(tmpdir, file_prefix)
        return data</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.backend_internal.get_js_sm"><code class="name flex">
<span>def <span class="ident">get_js_sm</span></span>(<span>watchinfo, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch watchinfo page and extract stream map and js funcs if not known.</p>
<p>This function is needed by videos with encrypted signatures.
If the js url referred to in the watchv page is not a key in funcmap,
the javascript is fetched and functions extracted.</p>
<p>Returns streammap (list of dicts), js url (str)
and funcs (dict)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_js_sm(watchinfo, callback):
    &#34;&#34;&#34; Fetch watchinfo page and extract stream map and js funcs if not known.

    This function is needed by videos with encrypted signatures.
    If the js url referred to in the watchv page is not a key in funcmap,
    the javascript is fetched and functions extracted.

    Returns streammap (list of dicts), js url (str)  and funcs (dict)

    &#34;&#34;&#34;
    m = re.search(g.jsplayer, watchinfo)
    myjson = json.loads(m.group(1))
    stream_info = myjson[&#39;args&#39;]
    sm = _extract_smap(g.UEFSM, stream_info, False)
    asm = _extract_smap(g.AF, stream_info, False)
    js_url = myjson[&#39;assets&#39;][&#39;js&#39;]
    js_url = &#34;https:&#34; + js_url if js_url.startswith(&#34;//&#34;) else js_url
    mainfunc = funcmap.get(js_url)

    if not mainfunc:
        dbg(&#34;Fetching javascript&#34;)
        if callback:
            callback(&#34;Fetching javascript&#34;)
        javascript = fetch_cached(js_url, callback, encoding=&#34;utf8&#34;,
                                  dbg_ref=&#34;javascript&#34;, file_prefix=&#34;js-&#34;)
        mainfunc = _get_mainfunc_from_js(javascript)

    elif mainfunc:
        dbg(&#34;Using functions in memory extracted from %s&#34;, js_url)
        dbg(&#34;Mem contains %s js func sets&#34;, len(funcmap))

    return (sm, asm), js_url, mainfunc</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.backend_internal.get_video_info"><code class="name flex">
<span>def <span class="ident">get_video_info</span></span>(<span>video_id, callback, newurl=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return info for video_id.
Returns dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_info(video_id, callback, newurl=None):
    &#34;&#34;&#34; Return info for video_id.  Returns dict. &#34;&#34;&#34;
    # TODO: see if there is a way to avoid retrieving the embed page
    #       just for this, or to use it for more. This was coppied from
    #       youtube-dl.
    embed_webpage = fetch_decode(g.urls[&#39;embed&#39;])
    sts = re.search(r&#39;sts&#34;\s*:\s*(\d+)&#39;, embed_webpage).group(1)

    url = g.urls[&#39;vidinfo&#39;] % (video_id, video_id, sts)
    url = newurl if newurl else url
    info = fetch_decode(url)  # bytes
    info = parseqs(info)  # unicode dict
    dbg(&#34;Fetched video info%s&#34;, &#34; (age ver)&#34; if newurl else &#34;&#34;)

    if info[&#39;status&#39;][0] == &#34;fail&#34;:
        reason = info[&#39;reason&#39;][0] or &#34;Bad video argument&#34;
        raise IOError(&#34;Youtube says: %s [%s]&#34; % (reason, video_id))

    return info</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.backend_internal.parseqs"><code class="name flex">
<span>def <span class="ident">parseqs</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>parse_qs, return unicode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parseqs(data):
    &#34;&#34;&#34; parse_qs, return unicode. &#34;&#34;&#34;
    if type(data) == uni:
        return parse_qs(data)

    elif pyver == 3:
        data = data.decode(&#34;utf8&#34;)
        data = parse_qs(data)

    else:
        data = parse_qs(data)
        out = {}

        for k, v in data.items():
            k = k.decode(&#34;utf8&#34;)
            out[k] = [x.decode(&#34;utf8&#34;) for x in v]
            data = out

    return data</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.backend_internal.prune_files"><code class="name flex">
<span>def <span class="ident">prune_files</span></span>(<span>path, prefix='', age_max=1209600, count_max=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the oldest files from path that start with prefix.</p>
<p>remove files older than age_max, leave maximum of count_max files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune_files(path, prefix=&#34;&#34;, age_max=3600 * 24 * 14, count_max=4):
    &#34;&#34;&#34; Remove the oldest files from path that start with prefix.

    remove files older than age_max, leave maximum of count_max files.
    &#34;&#34;&#34;
    tempfiles = []

    if not os.path.isdir(path):
        return

    for f in os.listdir(path):
        filepath = os.path.join(path, f)

        if os.path.isfile(filepath) and f.startswith(prefix):
            age = time.time() - os.path.getmtime(filepath)

            if age &gt; age_max:
                os.unlink(filepath)

            else:
                tempfiles.append((filepath, age))

    tempfiles = sorted(tempfiles, key=lambda x: x[1], reverse=True)

    for f in tempfiles[:-count_max]:
        os.unlink(f[0])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fastdub.youtube.pafy.backend_internal.InternPafy"><code class="flex name class">
<span>class <span class="ident">InternPafy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent a YouTube video. </p>
<p>Set initial values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternPafy(BasePafy):
    def __init__(self, *args, **kwargs):
        self.sm = []
        self.asm = []
        self.dash = []
        self.js_url = None  # if js_url is set then has new stream map
        self._dashurl = None
        self.age_ver = False
        self._formats = None
        self.ciphertag = None  # used by Stream class in url property def
        super(InternPafy, self).__init__(*args, **kwargs)

    def _fetch_basic(self):
        &#34;&#34;&#34; Fetch basic data and streams. &#34;&#34;&#34;
        if self._have_basic:
            return

        allinfo = get_video_info(self.videoid, self.callback)

        if self.callback:
            self.callback(&#34;Fetched video info&#34;)

        def _get_lst(key, default=&#34;unknown&#34;, dic=allinfo):
            &#34;&#34;&#34; Dict get function, returns first index. &#34;&#34;&#34;
            retval = dic.get(key, default)
            return retval[0] if retval != default else default

        self._title = _get_lst(&#39;title&#39;)
        self._dashurl = _get_lst(&#39;dashmpd&#39;)
        self._author = _get_lst(&#39;author&#39;)
        self._rating = float(_get_lst(&#39;avg_rating&#39;, 0.0))
        self._length = int(_get_lst(&#39;length_seconds&#39;, 0))
        self._viewcount = int(_get_lst(&#39;view_count&#39;, 0))
        self._thumb = unquote_plus(_get_lst(&#39;thumbnail_url&#39;, &#34;&#34;))
        self._formats = [x.split(&#34;/&#34;) for x in _get_lst(&#39;fmt_list&#39;).split(&#34;,&#34;)]
        self._keywords = _get_lst(&#39;keywords&#39;, &#34;&#34;).split(&#39;,&#39;)
        self._bigthumb = _get_lst(&#39;iurlsd&#39;, &#34;&#34;)
        self._bigthumbhd = _get_lst(&#39;iurlsdmaxres&#39;, &#34;&#34;)
        self.ciphertag = _get_lst(&#34;use_cipher_signature&#34;) == &#34;True&#34;
        self.sm = _extract_smap(g.UEFSM, allinfo, True)
        self.asm = _extract_smap(g.AF, allinfo, True)
        dbg(&#34;extracted stream maps&#34;)

        sm_ciphertag = &#34;s&#34; in self.sm[0]

        if self.ciphertag != sm_ciphertag:
            dbg(&#34;ciphertag mismatch&#34;)
            self.ciphertag = not self.ciphertag

        watch_url = g.urls[&#39;watchv&#39;] % self.videoid
        if self.callback:
            self.callback(&#34;Fetching watch page&#34;)
        watchinfo = fetch_decode(watch_url)  # unicode
        dbg(&#34;Fetched watch page&#34;)
        if self.callback:
            self.callback(&#34;Fetched watch page&#34;)
        self.age_ver = re.search(r&#39;player-age-gate-content&#34;&gt;&#39;, watchinfo) is not None

        if self.ciphertag:
            dbg(&#34;Encrypted signature detected.&#34;)

            if not self.age_ver:
                smaps, js_url, mainfunc = get_js_sm(watchinfo, self.callback)
                funcmap[js_url] = mainfunc
                self.sm, self.asm = smaps
                self.js_url = js_url
                dashsig = re.search(r&#34;/s/([\w.]+)&#34;, self._dashurl).group(1)
                dbg(&#34;decrypting dash sig&#34;)
                goodsig = _decodesig(dashsig, js_url, self.callback)
                self._dashurl = re.sub(r&#34;/s/[\w.]+&#34;,
                                       &#34;/signature/%s&#34; % goodsig, self._dashurl)

            else:
                s = re.search(r&#34;/s/([\w.]+)&#34;, self._dashurl).group(1)
                s = s[2:63] + s[82] + s[64:82] + s[63]
                self._dashurl = re.sub(r&#34;/s/[\w.]+&#34;,
                                       &#34;/signature/%s&#34; % s, self._dashurl)

        if self._dashurl != &#39;unknown&#39;:
            self.dash = _extract_dash(self._dashurl)
        self._have_basic = 1
        self._process_streams()
        self.expiry = time.time() + g.lifespan

    def _fetch_gdata(self):
        &#34;&#34;&#34; Extract gdata values, fetch gdata if necessary. &#34;&#34;&#34;
        if self._have_gdata:
            return

        item = self._get_video_gdata(self.videoid)[&#39;items&#39;][0]
        snippet = item[&#39;snippet&#39;]
        self._published = uni(snippet[&#39;publishedAt&#39;])
        self._description = uni(snippet[&#34;description&#34;])
        self._category = get_categoryname(snippet[&#39;categoryId&#39;])
        # TODO: Make sure actual usename is not available through the api
        self._username = uni(snippet[&#39;channelTitle&#39;])
        statistics = item[&#34;statistics&#34;]
        self._likes = int(statistics[&#34;likeCount&#34;])
        self._dislikes = int(statistics[&#34;dislikeCount&#34;])
        self._have_gdata = 1

    def _process_streams(self):
        &#34;&#34;&#34; Create Stream object lists from internal stream maps. &#34;&#34;&#34;
        if not self._have_basic:
            self._fetch_basic()

        streams = [InternStream(z, self) for z in self.sm]
        streams = [x for x in streams if x.itag in g.itags]
        adpt_streams = [InternStream(z, self) for z in self.asm]
        adpt_streams = [x for x in adpt_streams if x.itag in g.itags]
        dash_streams = [InternStream(z, self) for z in self.dash]
        dash_streams = [x for x in dash_streams if x.itag in g.itags]
        audiostreams = [x for x in adpt_streams if x.bitrate]
        videostreams = [x for x in adpt_streams if not x.bitrate]
        dash_itags = [x.itag for x in dash_streams]
        audiostreams = [x for x in audiostreams if x.itag not in dash_itags]
        videostreams = [x for x in videostreams if x.itag not in dash_itags]
        audiostreams += [x for x in dash_streams if x.mediatype == &#34;audio&#34;]
        videostreams += [x for x in dash_streams if x.mediatype != &#34;audio&#34;]
        audiostreams = sorted(audiostreams, key=lambda x: x.rawbitrate,
                              reverse=True)
        videostreams = sorted(videostreams, key=lambda x: x.dimensions,
                              reverse=True)
        m4astreams = [x for x in audiostreams if x.extension == &#34;m4a&#34;]
        oggstreams = [x for x in audiostreams if x.extension == &#34;ogg&#34;]
        self._streams = streams
        self._audiostreams = audiostreams
        self._videostreams = videostreams
        self._m4astreams, self._oggstreams = m4astreams, oggstreams
        self._allstreams = streams + videostreams + audiostreams</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fastdub.youtube.pafy.backend_shared.BasePafy" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy">BasePafy</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fastdub.youtube.pafy.backend_shared.BasePafy" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy">BasePafy</a></b></code>:
<ul class="hlist">
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.allstreams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.allstreams">allstreams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.audiostreams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.audiostreams">audiostreams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.author" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.author">author</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.bigthumb" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.bigthumb">bigthumb</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.bigthumbhd" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.bigthumbhd">bigthumbhd</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.category" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.category">category</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.description" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.description">description</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.dislikes" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.dislikes">dislikes</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.duration" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.duration">duration</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getbest" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getbest">getbest</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getbestaudio" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getbestaudio">getbestaudio</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getbestthumb" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getbestthumb">getbestthumb</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getbestvideo" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getbestvideo">getbestvideo</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getworst" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getworst">getworst</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getworstaudio" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getworstaudio">getworstaudio</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.getworstvideo" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.getworstvideo">getworstvideo</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.keywords" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.keywords">keywords</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.length" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.length">length</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.likes" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.likes">likes</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.m4astreams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.m4astreams">m4astreams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.mix" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.mix">mix</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.oggstreams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.oggstreams">oggstreams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.populate_from_playlist" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.populate_from_playlist">populate_from_playlist</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.published" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.published">published</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.rating" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.rating">rating</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.streams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.streams">streams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.thumb" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.thumb">thumb</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.title" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.title">title</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.username" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.username">username</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.videostreams" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.videostreams">videostreams</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BasePafy.viewcount" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BasePafy.viewcount">viewcount</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fastdub.youtube.pafy.backend_internal.InternStream"><code class="flex name class">
<span>class <span class="ident">InternStream</span></span>
<span>(</span><span>sm, parent)</span>
</code></dt>
<dd>
<div class="desc"><p>YouTube video stream class. </p>
<p>Set initial values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternStream(BaseStream):
    def __init__(self, sm, parent):
        super(InternStream, self).__init__(parent)

        self._itag = sm[&#39;itag&#39;]
        # is_dash = &#34;width&#34; in sm and &#34;height&#34; in sm
        is_dash = &#34;dash&#34; in sm

        if self._itag not in g.itags:
            logging.warning(&#34;Unknown itag: %s&#34;, self._itag)
            return

        self._mediatype = g.itags[self.itag][2]
        self._threed = &#39;stereo3d&#39; in sm and sm[&#39;stereo3d&#39;] == &#39;1&#39;

        if is_dash:
            if sm[&#39;width&#39;] != &#34;None&#34;:  # dash video
                self._resolution = &#34;%sx%s&#34; % (sm[&#39;width&#39;], sm[&#39;height&#39;])
                self._quality = self._resolution
                self._dimensions = (int(sm[&#39;width&#39;]), int(sm[&#39;height&#39;]))

            else:  # dash audio
                self._resolution = &#34;0x0&#34;
                self._dimensions = (0, 0)
                self._rawbitrate = int(sm[&#39;bitrate&#39;])
                # self._bitrate = uni(int(sm[&#39;bitrate&#39;]) // 1024) + &#34;k&#34;
                self._bitrate = g.itags[self.itag][0]
                self._quality = self._bitrate

            self._fsize = int(sm[&#39;size&#39;] or 0)
            # self._bitrate = sm[&#39;bitrate&#39;]
            # self._rawbitrate = uni(int(self._bitrate) // 1024) + &#34;k&#34;

        else:  # not dash
            self._resolution = g.itags[self.itag][0]
            self._dimensions = tuple(self.resolution.split(&#34;-&#34;)[0].split(&#34;x&#34;))
            self._dimensions = tuple([int(x) if x.isdigit() else x for x in
                                      self._dimensions])
            self._quality = self.resolution

        self._extension = g.itags[self.itag][1]
        self._title = parent.title
        self.encrypted = &#39;s&#39; in sm
        self._parent = parent
        self._filename = self.generate_filename()
        self._notes = g.itags[self.itag][3]
        self._rawurl = sm[&#39;url&#39;]
        self._sig = sm[&#39;s&#39;] if self.encrypted else sm.get(&#34;sig&#34;)
        self._active = False

        if self.mediatype == &#34;audio&#34; and not is_dash:
            self._dimensions = (0, 0)
            self._bitrate = self.resolution
            self._quality = self.bitrate
            self._resolution = &#34;0x0&#34;
            self._rawbitrate = int(sm[&#34;bitrate&#34;])

    @property
    def url(self):
        &#34;&#34;&#34; Return the url, decrypt if required. &#34;&#34;&#34;
        if not self._url:

            if self._parent.age_ver:

                if self._sig:
                    s = self._sig
                    self._sig = s[2:63] + s[82] + s[64:82] + s[63]

            elif self.encrypted:
                self._sig = _decodesig(self._sig, self._parent.js_url,
                                       self._parent.callback)

            self._url = _make_url(self._rawurl, self._sig)

        return self._url</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fastdub.youtube.pafy.backend_shared.BaseStream" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream">BaseStream</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fastdub.youtube.pafy.backend_shared.BaseStream" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream">BaseStream</a></b></code>:
<ul class="hlist">
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.bitrate" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.bitrate">bitrate</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.cancel" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.cancel">cancel</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.dimensions" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.dimensions">dimensions</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.download" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.download">download</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.extension" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.extension">extension</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.filename" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.filename">filename</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.generate_filename" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.generate_filename">generate_filename</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.get_filesize" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.get_filesize">get_filesize</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.itag" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.itag">itag</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.mediatype" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.mediatype">mediatype</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.notes" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.notes">notes</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.quality" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.quality">quality</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.rawbitrate" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.rawbitrate">rawbitrate</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.resolution" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.resolution">resolution</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.threed" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.threed">threed</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.title" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.title">title</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.url" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.url">url</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_shared.BaseStream.url_https" href="backend_shared.html#fastdub.youtube.pafy.backend_shared.BaseStream.url_https">url_https</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fastdub.youtube.pafy" href="index.html">fastdub.youtube.pafy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fastdub.youtube.pafy.backend_internal.fetch_cached" href="#fastdub.youtube.pafy.backend_internal.fetch_cached">fetch_cached</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_internal.get_js_sm" href="#fastdub.youtube.pafy.backend_internal.get_js_sm">get_js_sm</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_internal.get_video_info" href="#fastdub.youtube.pafy.backend_internal.get_video_info">get_video_info</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_internal.parseqs" href="#fastdub.youtube.pafy.backend_internal.parseqs">parseqs</a></code></li>
<li><code><a title="fastdub.youtube.pafy.backend_internal.prune_files" href="#fastdub.youtube.pafy.backend_internal.prune_files">prune_files</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fastdub.youtube.pafy.backend_internal.InternPafy" href="#fastdub.youtube.pafy.backend_internal.InternPafy">InternPafy</a></code></h4>
</li>
<li>
<h4><code><a title="fastdub.youtube.pafy.backend_internal.InternStream" href="#fastdub.youtube.pafy.backend_internal.InternStream">InternStream</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>