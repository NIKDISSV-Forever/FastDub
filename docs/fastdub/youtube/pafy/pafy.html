<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fastdub.youtube.pafy.pafy API documentation</title>
<meta name="description" content="pafy.py â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fastdub.youtube.pafy.pafy</code></h1>
</header>
<section id="section-intro">
<p>pafy.py.</p>
<p>Python library to download YouTube content and retrieve metadata</p>
<p><a href="https://github.com/mps-youtube/pafy">https://github.com/mps-youtube/pafy</a></p>
<p>Copyright (C)
2013-2014 np1</p>
<p>This program is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along
with this program.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
pafy.py.

Python library to download YouTube content and retrieve metadata

https://github.com/mps-youtube/pafy

Copyright (C)  2013-2014 np1

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;

import logging
import os
import re
import time
from urllib.error import HTTPError

from . import g
from .util import call_gdata

Pafy = None

# Select which backend to use
backend = &#34;internal&#34;
if os.environ.get(&#34;PAFY_BACKEND&#34;) != &#34;internal&#34;:
    try:
        import youtube_dl

        backend = &#34;youtube-dl&#34;
    except ImportError:
        raise ImportError(
            &#34;pafy: youtube-dl not found; you can use the internal backend by &#34;
            &#34;setting the environmental variable PAFY_BACKEND to \&#34;internal\&#34;. &#34;
            &#34;It is not enabled by default because it is not as well maintained &#34;
            &#34;as the youtube-dl backend.&#34;)

if os.environ.get(&#34;pafydebug&#34;) == &#34;1&#34;:
    logging.basicConfig(level=logging.DEBUG)

dbg = logging.debug


def fetch_decode(url, encoding=None):
    &#34;&#34;&#34; Fetch url and decode. &#34;&#34;&#34;
    try:
        req = g.opener.open(url)
    except HTTPError as e:
        if e.getcode() == 503:
            time.sleep(.5)
            return fetch_decode(url, encoding)
        else:
            raise

    ct = req.headers[&#39;content-type&#39;]

    if encoding:
        return req.read().decode(encoding)

    elif &#34;charset=&#34; in ct:
        dbg(&#34;charset: %s&#34;, ct)
        encoding = re.search(r&#34;charset=([\w-]+)\s*(:?;|$)&#34;, ct).group(1)
        return req.read().decode(encoding)

    else:
        dbg(&#34;encoding unknown&#34;)
        return req.read()


def new(url, basic=True, gdata=False, size=False,
        callback=None, ydl_opts=None):
    &#34;&#34;&#34; Return a new pafy instance given an url or video id.

    NOTE: The signature argument has been deprecated and now has no effect,
        it will be removed in a future version.

    Optional arguments:
        basic - fetch basic metadata and streams
        gdata - fetch gdata info (upload date, description, category)
        size - fetch the size of each stream (slow)(decrypts urls if needed)
        callback - a callback function to receive status strings

    If any of the first three above arguments are False, those data items will
    be fetched only when first called for.

    The defaults are recommended for most cases. If you wish to create
    many video objects at once, you may want to set basic to False, eg:

        video = pafy.new(basic=False)

    This will be quick because no http requests will be made on initialisation.

    Setting size to True will override the basic argument and force basic data
    to be fetched too (basic data is required to obtain Stream objects).

    &#34;&#34;&#34;
    global Pafy
    if Pafy is None:
        if backend == &#34;internal&#34;:
            from .backend_internal import InternPafy as Pafy
        else:
            from .backend_youtube_dl import YtdlPafy as Pafy

    return Pafy(url, basic, gdata, size, callback, ydl_opts=ydl_opts)


def cache(name):
    &#34;&#34;&#34; Returns a sub-cache dictionary under which global key, value pairs
    can be stored. Regardless of whether a dictionary already exists for
    the given name, the sub-cache is returned by reference.
    &#34;&#34;&#34;
    if name not in g.cache:
        g.cache[name] = {}
    return g.cache[name]


def get_categoryname(cat_id):
    &#34;&#34;&#34; Returns a list of video category names for one category ID. &#34;&#34;&#34;
    timestamp = time.time()
    cat_cache = cache(&#39;categories&#39;)
    cached = cat_cache.get(cat_id, {})
    if cached.get(&#39;updated&#39;, 0) &gt; timestamp - g.lifespan:
        return cached.get(&#39;title&#39;, &#39;unknown&#39;)
    # call videoCategories API endpoint to retrieve title
    query = {&#39;id&#39;: cat_id,
             &#39;part&#39;: &#39;snippet&#39;}
    catinfo = call_gdata(&#39;videoCategories&#39;, query)
    try:
        for item in catinfo.get(&#39;items&#39;, []):
            title = item.get(&#39;snippet&#39;, {}).get(&#39;title&#39;, &#39;unknown&#39;)
            cat_cache[cat_id] = {&#39;title&#39;: title, &#39;updated&#39;: timestamp}
            return title
        cat_cache[cat_id] = {&#39;updated&#39;: timestamp}
        return &#39;unknown&#39;
    except Exception:
        raise IOError(&#34;Error fetching category name for ID %s&#34; % cat_id)


def set_categories(categories):
    &#34;&#34;&#34; Take a dictionary mapping video category IDs to name and retrieval
    time. All items are stored into cache node &#39;videoCategories&#39;, but
    for the ones with a retrieval time too long ago, the v3 API is queried
    before.
    &#34;&#34;&#34;
    timestamp = time.time()
    idlist = [cid for cid, item in categories.items()
              if item.get(&#39;updated&#39;, 0) &lt; timestamp - g.lifespan]
    if len(idlist) &gt; 0:
        query = {&#39;id&#39;: &#39;,&#39;.join(idlist),
                 &#39;part&#39;: &#39;snippet&#39;}
        catinfo = call_gdata(&#39;videoCategories&#39;, query)
        try:
            for item in catinfo.get(&#39;items&#39;, []):
                cid = item[&#39;id&#39;]
                title = item.get(&#39;snippet&#39;, {}).get(&#39;title&#39;, &#39;unknown&#39;)
                categories[cid] = {&#39;title&#39;: title, &#39;updated&#39;: timestamp}
        except Exception:
            raise IOError(&#34;Error fetching category name for IDs %s&#34; % idlist)
    cache(&#39;categories&#39;).update(categories)


def load_cache(newcache):
    &#34;&#34;&#34;Loads a dict into pafy&#39;s internal cache.&#34;&#34;&#34;
    set_categories(newcache.get(&#39;categories&#39;, {}))


def dump_cache():
    &#34;&#34;&#34;Returns pafy&#39;s cache for storing by program.&#34;&#34;&#34;
    return g.cache


def set_api_key(key):
    &#34;&#34;&#34;Sets the api key to be used with YouTube.&#34;&#34;&#34;
    g.api_key = key</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fastdub.youtube.pafy.pafy.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sub-cache dictionary under which global key, value pairs
can be stored. Regardless of whether a dictionary already exists for
the given name, the sub-cache is returned by reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache(name):
    &#34;&#34;&#34; Returns a sub-cache dictionary under which global key, value pairs
    can be stored. Regardless of whether a dictionary already exists for
    the given name, the sub-cache is returned by reference.
    &#34;&#34;&#34;
    if name not in g.cache:
        g.cache[name] = {}
    return g.cache[name]</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.dump_cache"><code class="name flex">
<span>def <span class="ident">dump_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns pafy's cache for storing by program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_cache():
    &#34;&#34;&#34;Returns pafy&#39;s cache for storing by program.&#34;&#34;&#34;
    return g.cache</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.fetch_decode"><code class="name flex">
<span>def <span class="ident">fetch_decode</span></span>(<span>url, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch url and decode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_decode(url, encoding=None):
    &#34;&#34;&#34; Fetch url and decode. &#34;&#34;&#34;
    try:
        req = g.opener.open(url)
    except HTTPError as e:
        if e.getcode() == 503:
            time.sleep(.5)
            return fetch_decode(url, encoding)
        else:
            raise

    ct = req.headers[&#39;content-type&#39;]

    if encoding:
        return req.read().decode(encoding)

    elif &#34;charset=&#34; in ct:
        dbg(&#34;charset: %s&#34;, ct)
        encoding = re.search(r&#34;charset=([\w-]+)\s*(:?;|$)&#34;, ct).group(1)
        return req.read().decode(encoding)

    else:
        dbg(&#34;encoding unknown&#34;)
        return req.read()</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.get_categoryname"><code class="name flex">
<span>def <span class="ident">get_categoryname</span></span>(<span>cat_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of video category names for one category ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_categoryname(cat_id):
    &#34;&#34;&#34; Returns a list of video category names for one category ID. &#34;&#34;&#34;
    timestamp = time.time()
    cat_cache = cache(&#39;categories&#39;)
    cached = cat_cache.get(cat_id, {})
    if cached.get(&#39;updated&#39;, 0) &gt; timestamp - g.lifespan:
        return cached.get(&#39;title&#39;, &#39;unknown&#39;)
    # call videoCategories API endpoint to retrieve title
    query = {&#39;id&#39;: cat_id,
             &#39;part&#39;: &#39;snippet&#39;}
    catinfo = call_gdata(&#39;videoCategories&#39;, query)
    try:
        for item in catinfo.get(&#39;items&#39;, []):
            title = item.get(&#39;snippet&#39;, {}).get(&#39;title&#39;, &#39;unknown&#39;)
            cat_cache[cat_id] = {&#39;title&#39;: title, &#39;updated&#39;: timestamp}
            return title
        cat_cache[cat_id] = {&#39;updated&#39;: timestamp}
        return &#39;unknown&#39;
    except Exception:
        raise IOError(&#34;Error fetching category name for ID %s&#34; % cat_id)</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.load_cache"><code class="name flex">
<span>def <span class="ident">load_cache</span></span>(<span>newcache)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a dict into pafy's internal cache.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_cache(newcache):
    &#34;&#34;&#34;Loads a dict into pafy&#39;s internal cache.&#34;&#34;&#34;
    set_categories(newcache.get(&#39;categories&#39;, {}))</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>url, basic=True, gdata=False, size=False, callback=None, ydl_opts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new pafy instance given an url or video id.</p>
<p>NOTE: The signature argument has been deprecated and now has no effect,
it will be removed in a future version.</p>
<p>Optional arguments:
basic - fetch basic metadata and streams
gdata - fetch gdata info (upload date, description, category)
size - fetch the size of each stream (slow)(decrypts urls if needed)
callback - a callback function to receive status strings</p>
<p>If any of the first three above arguments are False, those data items will
be fetched only when first called for.</p>
<p>The defaults are recommended for most cases. If you wish to create
many video objects at once, you may want to set basic to False, eg:</p>
<pre><code>video = pafy.new(basic=False)
</code></pre>
<p>This will be quick because no http requests will be made on initialisation.</p>
<p>Setting size to True will override the basic argument and force basic data
to be fetched too (basic data is required to obtain Stream objects).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new(url, basic=True, gdata=False, size=False,
        callback=None, ydl_opts=None):
    &#34;&#34;&#34; Return a new pafy instance given an url or video id.

    NOTE: The signature argument has been deprecated and now has no effect,
        it will be removed in a future version.

    Optional arguments:
        basic - fetch basic metadata and streams
        gdata - fetch gdata info (upload date, description, category)
        size - fetch the size of each stream (slow)(decrypts urls if needed)
        callback - a callback function to receive status strings

    If any of the first three above arguments are False, those data items will
    be fetched only when first called for.

    The defaults are recommended for most cases. If you wish to create
    many video objects at once, you may want to set basic to False, eg:

        video = pafy.new(basic=False)

    This will be quick because no http requests will be made on initialisation.

    Setting size to True will override the basic argument and force basic data
    to be fetched too (basic data is required to obtain Stream objects).

    &#34;&#34;&#34;
    global Pafy
    if Pafy is None:
        if backend == &#34;internal&#34;:
            from .backend_internal import InternPafy as Pafy
        else:
            from .backend_youtube_dl import YtdlPafy as Pafy

    return Pafy(url, basic, gdata, size, callback, ydl_opts=ydl_opts)</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.set_api_key"><code class="name flex">
<span>def <span class="ident">set_api_key</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the api key to be used with YouTube.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_api_key(key):
    &#34;&#34;&#34;Sets the api key to be used with YouTube.&#34;&#34;&#34;
    g.api_key = key</code></pre>
</details>
</dd>
<dt id="fastdub.youtube.pafy.pafy.set_categories"><code class="name flex">
<span>def <span class="ident">set_categories</span></span>(<span>categories)</span>
</code></dt>
<dd>
<div class="desc"><p>Take a dictionary mapping video category IDs to name and retrieval
time. All items are stored into cache node 'videoCategories', but
for the ones with a retrieval time too long ago, the v3 API is queried
before.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_categories(categories):
    &#34;&#34;&#34; Take a dictionary mapping video category IDs to name and retrieval
    time. All items are stored into cache node &#39;videoCategories&#39;, but
    for the ones with a retrieval time too long ago, the v3 API is queried
    before.
    &#34;&#34;&#34;
    timestamp = time.time()
    idlist = [cid for cid, item in categories.items()
              if item.get(&#39;updated&#39;, 0) &lt; timestamp - g.lifespan]
    if len(idlist) &gt; 0:
        query = {&#39;id&#39;: &#39;,&#39;.join(idlist),
                 &#39;part&#39;: &#39;snippet&#39;}
        catinfo = call_gdata(&#39;videoCategories&#39;, query)
        try:
            for item in catinfo.get(&#39;items&#39;, []):
                cid = item[&#39;id&#39;]
                title = item.get(&#39;snippet&#39;, {}).get(&#39;title&#39;, &#39;unknown&#39;)
                categories[cid] = {&#39;title&#39;: title, &#39;updated&#39;: timestamp}
        except Exception:
            raise IOError(&#34;Error fetching category name for IDs %s&#34; % idlist)
    cache(&#39;categories&#39;).update(categories)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fastdub.youtube.pafy" href="index.html">fastdub.youtube.pafy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fastdub.youtube.pafy.pafy.cache" href="#fastdub.youtube.pafy.pafy.cache">cache</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.dump_cache" href="#fastdub.youtube.pafy.pafy.dump_cache">dump_cache</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.fetch_decode" href="#fastdub.youtube.pafy.pafy.fetch_decode">fetch_decode</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.get_categoryname" href="#fastdub.youtube.pafy.pafy.get_categoryname">get_categoryname</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.load_cache" href="#fastdub.youtube.pafy.pafy.load_cache">load_cache</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.new" href="#fastdub.youtube.pafy.pafy.new">new</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.set_api_key" href="#fastdub.youtube.pafy.pafy.set_api_key">set_api_key</a></code></li>
<li><code><a title="fastdub.youtube.pafy.pafy.set_categories" href="#fastdub.youtube.pafy.pafy.set_categories">set_categories</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>