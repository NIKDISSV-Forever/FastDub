<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fastdub.dubber API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fastdub.dubber</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import logging
import os.path
import shutil
from pathlib import Path
from typing import Sequence

import rich.align
from tqdm import tqdm

from fastdub import audio, subtitles, voicer, GlobalSettings
from fastdub.audio import AudioSegment, calc_speed_change_ffmpeg_arg
from fastdub.ffmpeg_wrapper import FFMpegWrapper

__all__ = (&#39;Dubber&#39;, &#39;VOICER&#39;)

from fastdub.subtitles import Line, TimeLabel

VOICER = voicer.Voicer()


class Dubber:
    __slots__ = (
        &#39;fit_align&#39;, &#39;language&#39;, &#39;audio_format&#39;,
        &#39;cleanup_audio&#39;, &#39;export_video&#39;,
        &#39;ducking&#39;,
        &#39;sidechain_level_sc&#39;, &#39;sidechain_ffmpeg_params&#39;
    )

    def __init__(self, voice: str, language: str, audio_format: str,
                 ducking: bool, sidechain_level_sc: float, sidechain_ffmpeg_params: str,
                 fit_align: float = 2., cleanup_audio: bool = True, export_video: bool = True):
        self.language = language
        self.audio_format = audio_format
        self.fit_align = fit_align
        if voice:
            VOICER.set_voice(voice)

        self.ducking = ducking
        self.sidechain_level_sc = sidechain_level_sc
        self.sidechain_ffmpeg_params = sidechain_ffmpeg_params

        self.cleanup_audio = cleanup_audio
        self.export_video = export_video

    @staticmethod
    def collect_videos(path_to_files: str, skip_starts_underscore: bool = True,
                       exclude_files: Sequence[str] = frozenset()):
        path_to_files = os.path.abspath(path_to_files)
        videos = {}
        for file in os.listdir(path_to_files):
            if file in exclude_files:
                continue
            absfile = os.path.join(path_to_files, file)
            if not os.path.isfile(absfile) or skip_starts_underscore and file.startswith(&#39;_&#39;):
                continue
            filename, ext = os.path.splitext(file)
            if videos.get(filename):
                videos[filename][ext] = absfile
                continue
            videos[filename] = {ext: os.path.join(path_to_files, file)}
        return videos

    def dub_dir(self, videos: dict[str, dict[str, str]], video_format: str, subtitles_format: str):
        for fn, exts in videos.items():
            self.dub_one(fn, exts.get(video_format), exts.get(subtitles_format))

    def dub_one(self, fn: str, target_vid: str, target_sub: str, cleanup_audio: bool = None, export_video: bool = None):
        if target_vid is None and target_sub is None:
            return
        if cleanup_audio is None:
            cleanup_audio = self.cleanup_audio
        if export_video is None:
            export_video = self.export_video

        logging.info(f&#39;start voice file {fn!r}&#39;)
        result_dir = Path(target_sub).parent / &#39;_result&#39;
        result_dir.mkdir(exist_ok=True)
        out_audio_base = result_dir / f&#39;{fn}_{self.language}.{self.audio_format}&#39;

        subs = subtitles.parse(target_sub)
        default_right_border = 0
        if target_vid and subs:
            default_right_border = FFMpegWrapper.get_video_duration_ms(target_vid)
        default_right_border = max(default_right_border, end := subs[-1].ms.end)
        subs += Line(TimeLabel(default_right_border, end, end - default_right_border)),

        progress_total = len(subs) - 1

        fit_align = self.fit_align
        audio_format = self.audio_format

        working_dir = result_dir / &#39;_working_dir&#39;
        working_dir.mkdir(exist_ok=True)

        filenames: tuple[str] = *map(
            str(working_dir / (&#39;{0:0&gt;%i}.%s&#39; % (len(str(progress_total)), audio_format))).format, range(len(subs))),

        filename_sub = *zip(filenames_striped := filenames[:-1], subs[:-1]),
        cached_tts = [VOICER.voice(line.text) for fn, line in tqdm(filename_sub,
                                                                   desc=&#39;TTS&#39;,
                                                                   total=progress_total, unit=&#39;line&#39;,
                                                                   dynamic_ncols=True)]

        total_duration_ms = 0
        for pos, ((tts_fn, line), cached) in tqdm(
                enumerate(zip(filename_sub, cached_tts), 1),
                desc=&#39;Fitting&#39;,
                total=progress_total, unit=&#39;line&#39;,
                **GlobalSettings.tqdm_kwargs):
            ms = line.ms
            new_audio = audio.fit(
                AudioSegment.from_file(cached, &#39;wav&#39;),
                ms.start - total_duration_ms,
                ms.duration,
                subs[pos].ms.start - ms.end,
                fit_align
            )
            total_duration_ms += new_audio.duration_ms
            new_audio.export(tts_fn, audio_format)
        with open(list_file := working_dir / &#39;list.txt&#39;, &#39;w&#39;) as f:
            f.writelines(f&#34;file &#39;{fn}&#39;\n&#34; for fn in filenames_striped)
        max_duration = subs[-1].ms.end

        ffmpeg_concat_args = ()
        if total_duration_ms &gt; max_duration:
            change_speed = total_duration_ms / max_duration
            logging.info(f&#39;changing audio speed {change_speed:g}&#39;)
            ffmpeg_concat_args += &#39;-af&#39;, calc_speed_change_ffmpeg_arg(change_speed)
        else:
            ffmpeg_concat_args += &#39;-c&#39;, &#39;copy&#39;

        temp_audio_file = str(out_audio_base.with_stem(f&#39;_{out_audio_base.stem}&#39;))
        logging.info(&#39;concatenating parts...&#39;)
        FFMpegWrapper.convert(&#39;-f&#39;, &#39;concat&#39;, &#39;-safe&#39;, &#39;0&#39;, &#39;-i&#39;, list_file, *ffmpeg_concat_args,
                              temp_audio_file)
        cur_audio = audio.AudioSegment.from_file(temp_audio_file)
        shutil.rmtree(working_dir, ignore_errors=True)

        if total_duration_ms != max_duration:
            cur_audio = audio.AudioSegment.silent(
                min(max_duration - total_duration_ms, subs[0].ms.start)
            ) + cur_audio

        result_out_audio = str(out_audio_base)
        if target_vid:
            cur_audio.export(temp_audio_file, format=&#39;wav&#39;)
            if self.ducking:
                logging.info(&#39;sidechain&#39;)
                FFMpegWrapper.sidechain(target_vid,
                                        temp_audio_file,
                                        result_out_audio,
                                        self.sidechain_level_sc,
                                        self.sidechain_ffmpeg_params)
            else:
                logging.info(&#39;amix&#39;)
                FFMpegWrapper.amix(target_vid, temp_audio_file, out=result_out_audio)
                # audio.AudioSegment.from_file(target_vid).overlay(cur_audio).export(result_out_audio)
            if export_video:
                FFMpegWrapper.save_result_data(target_vid, result_out_audio, target_sub,
                                               result_dir / f&#39;{fn}_{self.language}.mkv&#39;)
                if cleanup_audio:
                    os.remove(result_out_audio)
        else:
            cur_audio.export(result_out_audio)
        os.remove(temp_audio_file)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fastdub.dubber.Dubber"><code class="flex name class">
<span>class <span class="ident">Dubber</span></span>
<span>(</span><span>voice: str, language: str, audio_format: str, ducking: bool, sidechain_level_sc: float, sidechain_ffmpeg_params: str, fit_align: float = 2.0, cleanup_audio: bool = True, export_video: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dubber:
    __slots__ = (
        &#39;fit_align&#39;, &#39;language&#39;, &#39;audio_format&#39;,
        &#39;cleanup_audio&#39;, &#39;export_video&#39;,
        &#39;ducking&#39;,
        &#39;sidechain_level_sc&#39;, &#39;sidechain_ffmpeg_params&#39;
    )

    def __init__(self, voice: str, language: str, audio_format: str,
                 ducking: bool, sidechain_level_sc: float, sidechain_ffmpeg_params: str,
                 fit_align: float = 2., cleanup_audio: bool = True, export_video: bool = True):
        self.language = language
        self.audio_format = audio_format
        self.fit_align = fit_align
        if voice:
            VOICER.set_voice(voice)

        self.ducking = ducking
        self.sidechain_level_sc = sidechain_level_sc
        self.sidechain_ffmpeg_params = sidechain_ffmpeg_params

        self.cleanup_audio = cleanup_audio
        self.export_video = export_video

    @staticmethod
    def collect_videos(path_to_files: str, skip_starts_underscore: bool = True,
                       exclude_files: Sequence[str] = frozenset()):
        path_to_files = os.path.abspath(path_to_files)
        videos = {}
        for file in os.listdir(path_to_files):
            if file in exclude_files:
                continue
            absfile = os.path.join(path_to_files, file)
            if not os.path.isfile(absfile) or skip_starts_underscore and file.startswith(&#39;_&#39;):
                continue
            filename, ext = os.path.splitext(file)
            if videos.get(filename):
                videos[filename][ext] = absfile
                continue
            videos[filename] = {ext: os.path.join(path_to_files, file)}
        return videos

    def dub_dir(self, videos: dict[str, dict[str, str]], video_format: str, subtitles_format: str):
        for fn, exts in videos.items():
            self.dub_one(fn, exts.get(video_format), exts.get(subtitles_format))

    def dub_one(self, fn: str, target_vid: str, target_sub: str, cleanup_audio: bool = None, export_video: bool = None):
        if target_vid is None and target_sub is None:
            return
        if cleanup_audio is None:
            cleanup_audio = self.cleanup_audio
        if export_video is None:
            export_video = self.export_video

        logging.info(f&#39;start voice file {fn!r}&#39;)
        result_dir = Path(target_sub).parent / &#39;_result&#39;
        result_dir.mkdir(exist_ok=True)
        out_audio_base = result_dir / f&#39;{fn}_{self.language}.{self.audio_format}&#39;

        subs = subtitles.parse(target_sub)
        default_right_border = 0
        if target_vid and subs:
            default_right_border = FFMpegWrapper.get_video_duration_ms(target_vid)
        default_right_border = max(default_right_border, end := subs[-1].ms.end)
        subs += Line(TimeLabel(default_right_border, end, end - default_right_border)),

        progress_total = len(subs) - 1

        fit_align = self.fit_align
        audio_format = self.audio_format

        working_dir = result_dir / &#39;_working_dir&#39;
        working_dir.mkdir(exist_ok=True)

        filenames: tuple[str] = *map(
            str(working_dir / (&#39;{0:0&gt;%i}.%s&#39; % (len(str(progress_total)), audio_format))).format, range(len(subs))),

        filename_sub = *zip(filenames_striped := filenames[:-1], subs[:-1]),
        cached_tts = [VOICER.voice(line.text) for fn, line in tqdm(filename_sub,
                                                                   desc=&#39;TTS&#39;,
                                                                   total=progress_total, unit=&#39;line&#39;,
                                                                   dynamic_ncols=True)]

        total_duration_ms = 0
        for pos, ((tts_fn, line), cached) in tqdm(
                enumerate(zip(filename_sub, cached_tts), 1),
                desc=&#39;Fitting&#39;,
                total=progress_total, unit=&#39;line&#39;,
                **GlobalSettings.tqdm_kwargs):
            ms = line.ms
            new_audio = audio.fit(
                AudioSegment.from_file(cached, &#39;wav&#39;),
                ms.start - total_duration_ms,
                ms.duration,
                subs[pos].ms.start - ms.end,
                fit_align
            )
            total_duration_ms += new_audio.duration_ms
            new_audio.export(tts_fn, audio_format)
        with open(list_file := working_dir / &#39;list.txt&#39;, &#39;w&#39;) as f:
            f.writelines(f&#34;file &#39;{fn}&#39;\n&#34; for fn in filenames_striped)
        max_duration = subs[-1].ms.end

        ffmpeg_concat_args = ()
        if total_duration_ms &gt; max_duration:
            change_speed = total_duration_ms / max_duration
            logging.info(f&#39;changing audio speed {change_speed:g}&#39;)
            ffmpeg_concat_args += &#39;-af&#39;, calc_speed_change_ffmpeg_arg(change_speed)
        else:
            ffmpeg_concat_args += &#39;-c&#39;, &#39;copy&#39;

        temp_audio_file = str(out_audio_base.with_stem(f&#39;_{out_audio_base.stem}&#39;))
        logging.info(&#39;concatenating parts...&#39;)
        FFMpegWrapper.convert(&#39;-f&#39;, &#39;concat&#39;, &#39;-safe&#39;, &#39;0&#39;, &#39;-i&#39;, list_file, *ffmpeg_concat_args,
                              temp_audio_file)
        cur_audio = audio.AudioSegment.from_file(temp_audio_file)
        shutil.rmtree(working_dir, ignore_errors=True)

        if total_duration_ms != max_duration:
            cur_audio = audio.AudioSegment.silent(
                min(max_duration - total_duration_ms, subs[0].ms.start)
            ) + cur_audio

        result_out_audio = str(out_audio_base)
        if target_vid:
            cur_audio.export(temp_audio_file, format=&#39;wav&#39;)
            if self.ducking:
                logging.info(&#39;sidechain&#39;)
                FFMpegWrapper.sidechain(target_vid,
                                        temp_audio_file,
                                        result_out_audio,
                                        self.sidechain_level_sc,
                                        self.sidechain_ffmpeg_params)
            else:
                logging.info(&#39;amix&#39;)
                FFMpegWrapper.amix(target_vid, temp_audio_file, out=result_out_audio)
                # audio.AudioSegment.from_file(target_vid).overlay(cur_audio).export(result_out_audio)
            if export_video:
                FFMpegWrapper.save_result_data(target_vid, result_out_audio, target_sub,
                                               result_dir / f&#39;{fn}_{self.language}.mkv&#39;)
                if cleanup_audio:
                    os.remove(result_out_audio)
        else:
            cur_audio.export(result_out_audio)
        os.remove(temp_audio_file)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fastdub.dubber.Dubber.collect_videos"><code class="name flex">
<span>def <span class="ident">collect_videos</span></span>(<span>path_to_files: str, skip_starts_underscore: bool = True, exclude_files: Sequence[str] = frozenset())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def collect_videos(path_to_files: str, skip_starts_underscore: bool = True,
                   exclude_files: Sequence[str] = frozenset()):
    path_to_files = os.path.abspath(path_to_files)
    videos = {}
    for file in os.listdir(path_to_files):
        if file in exclude_files:
            continue
        absfile = os.path.join(path_to_files, file)
        if not os.path.isfile(absfile) or skip_starts_underscore and file.startswith(&#39;_&#39;):
            continue
        filename, ext = os.path.splitext(file)
        if videos.get(filename):
            videos[filename][ext] = absfile
            continue
        videos[filename] = {ext: os.path.join(path_to_files, file)}
    return videos</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fastdub.dubber.Dubber.audio_format"><code class="name">var <span class="ident">audio_format</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.cleanup_audio"><code class="name">var <span class="ident">cleanup_audio</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.ducking"><code class="name">var <span class="ident">ducking</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.export_video"><code class="name">var <span class="ident">export_video</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.fit_align"><code class="name">var <span class="ident">fit_align</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.language"><code class="name">var <span class="ident">language</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.sidechain_ffmpeg_params"><code class="name">var <span class="ident">sidechain_ffmpeg_params</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="fastdub.dubber.Dubber.sidechain_level_sc"><code class="name">var <span class="ident">sidechain_level_sc</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fastdub.dubber.Dubber.dub_dir"><code class="name flex">
<span>def <span class="ident">dub_dir</span></span>(<span>self, videos: dict[str, dict[str, str]], video_format: str, subtitles_format: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dub_dir(self, videos: dict[str, dict[str, str]], video_format: str, subtitles_format: str):
    for fn, exts in videos.items():
        self.dub_one(fn, exts.get(video_format), exts.get(subtitles_format))</code></pre>
</details>
</dd>
<dt id="fastdub.dubber.Dubber.dub_one"><code class="name flex">
<span>def <span class="ident">dub_one</span></span>(<span>self, fn: str, target_vid: str, target_sub: str, cleanup_audio: bool = None, export_video: bool = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dub_one(self, fn: str, target_vid: str, target_sub: str, cleanup_audio: bool = None, export_video: bool = None):
    if target_vid is None and target_sub is None:
        return
    if cleanup_audio is None:
        cleanup_audio = self.cleanup_audio
    if export_video is None:
        export_video = self.export_video

    logging.info(f&#39;start voice file {fn!r}&#39;)
    result_dir = Path(target_sub).parent / &#39;_result&#39;
    result_dir.mkdir(exist_ok=True)
    out_audio_base = result_dir / f&#39;{fn}_{self.language}.{self.audio_format}&#39;

    subs = subtitles.parse(target_sub)
    default_right_border = 0
    if target_vid and subs:
        default_right_border = FFMpegWrapper.get_video_duration_ms(target_vid)
    default_right_border = max(default_right_border, end := subs[-1].ms.end)
    subs += Line(TimeLabel(default_right_border, end, end - default_right_border)),

    progress_total = len(subs) - 1

    fit_align = self.fit_align
    audio_format = self.audio_format

    working_dir = result_dir / &#39;_working_dir&#39;
    working_dir.mkdir(exist_ok=True)

    filenames: tuple[str] = *map(
        str(working_dir / (&#39;{0:0&gt;%i}.%s&#39; % (len(str(progress_total)), audio_format))).format, range(len(subs))),

    filename_sub = *zip(filenames_striped := filenames[:-1], subs[:-1]),
    cached_tts = [VOICER.voice(line.text) for fn, line in tqdm(filename_sub,
                                                               desc=&#39;TTS&#39;,
                                                               total=progress_total, unit=&#39;line&#39;,
                                                               dynamic_ncols=True)]

    total_duration_ms = 0
    for pos, ((tts_fn, line), cached) in tqdm(
            enumerate(zip(filename_sub, cached_tts), 1),
            desc=&#39;Fitting&#39;,
            total=progress_total, unit=&#39;line&#39;,
            **GlobalSettings.tqdm_kwargs):
        ms = line.ms
        new_audio = audio.fit(
            AudioSegment.from_file(cached, &#39;wav&#39;),
            ms.start - total_duration_ms,
            ms.duration,
            subs[pos].ms.start - ms.end,
            fit_align
        )
        total_duration_ms += new_audio.duration_ms
        new_audio.export(tts_fn, audio_format)
    with open(list_file := working_dir / &#39;list.txt&#39;, &#39;w&#39;) as f:
        f.writelines(f&#34;file &#39;{fn}&#39;\n&#34; for fn in filenames_striped)
    max_duration = subs[-1].ms.end

    ffmpeg_concat_args = ()
    if total_duration_ms &gt; max_duration:
        change_speed = total_duration_ms / max_duration
        logging.info(f&#39;changing audio speed {change_speed:g}&#39;)
        ffmpeg_concat_args += &#39;-af&#39;, calc_speed_change_ffmpeg_arg(change_speed)
    else:
        ffmpeg_concat_args += &#39;-c&#39;, &#39;copy&#39;

    temp_audio_file = str(out_audio_base.with_stem(f&#39;_{out_audio_base.stem}&#39;))
    logging.info(&#39;concatenating parts...&#39;)
    FFMpegWrapper.convert(&#39;-f&#39;, &#39;concat&#39;, &#39;-safe&#39;, &#39;0&#39;, &#39;-i&#39;, list_file, *ffmpeg_concat_args,
                          temp_audio_file)
    cur_audio = audio.AudioSegment.from_file(temp_audio_file)
    shutil.rmtree(working_dir, ignore_errors=True)

    if total_duration_ms != max_duration:
        cur_audio = audio.AudioSegment.silent(
            min(max_duration - total_duration_ms, subs[0].ms.start)
        ) + cur_audio

    result_out_audio = str(out_audio_base)
    if target_vid:
        cur_audio.export(temp_audio_file, format=&#39;wav&#39;)
        if self.ducking:
            logging.info(&#39;sidechain&#39;)
            FFMpegWrapper.sidechain(target_vid,
                                    temp_audio_file,
                                    result_out_audio,
                                    self.sidechain_level_sc,
                                    self.sidechain_ffmpeg_params)
        else:
            logging.info(&#39;amix&#39;)
            FFMpegWrapper.amix(target_vid, temp_audio_file, out=result_out_audio)
            # audio.AudioSegment.from_file(target_vid).overlay(cur_audio).export(result_out_audio)
        if export_video:
            FFMpegWrapper.save_result_data(target_vid, result_out_audio, target_sub,
                                           result_dir / f&#39;{fn}_{self.language}.mkv&#39;)
            if cleanup_audio:
                os.remove(result_out_audio)
    else:
        cur_audio.export(result_out_audio)
    os.remove(temp_audio_file)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fastdub" href="index.html">fastdub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fastdub.dubber.Dubber" href="#fastdub.dubber.Dubber">Dubber</a></code></h4>
<ul class="">
<li><code><a title="fastdub.dubber.Dubber.audio_format" href="#fastdub.dubber.Dubber.audio_format">audio_format</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.cleanup_audio" href="#fastdub.dubber.Dubber.cleanup_audio">cleanup_audio</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.collect_videos" href="#fastdub.dubber.Dubber.collect_videos">collect_videos</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.dub_dir" href="#fastdub.dubber.Dubber.dub_dir">dub_dir</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.dub_one" href="#fastdub.dubber.Dubber.dub_one">dub_one</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.ducking" href="#fastdub.dubber.Dubber.ducking">ducking</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.export_video" href="#fastdub.dubber.Dubber.export_video">export_video</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.fit_align" href="#fastdub.dubber.Dubber.fit_align">fit_align</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.language" href="#fastdub.dubber.Dubber.language">language</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.sidechain_ffmpeg_params" href="#fastdub.dubber.Dubber.sidechain_ffmpeg_params">sidechain_ffmpeg_params</a></code></li>
<li><code><a title="fastdub.dubber.Dubber.sidechain_level_sc" href="#fastdub.dubber.Dubber.sidechain_level_sc">sidechain_level_sc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>